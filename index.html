<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>That Time I Generated a Grid on My Image</title>
    
    <script>
        // Inline Theme Script to prevent flash of wrong theme
        (function() {
            const savedTheme = localStorage.getItem('theme');
            const prefersDark = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches;
            if (savedTheme === 'dark' || (!savedTheme && prefersDark)) {
                document.documentElement.setAttribute('data-theme', 'dark');
            }
        })();
    </script>

    <style>
        /* --- 1. Modern CSS Variables (High Contrast) --- */
        :root {
            /* Light Theme */
            --bg-body: #eef2f5;
            --bg-card: #ffffff;
            --bg-input: #f8f9fa;
            --text-main: #212529;
            --text-muted: #6c757d;
            --border: #ced4da;
            --primary: #0d6efd;
            --primary-hover: #0b5ed7;
            --danger: #dc3545;
            --success: #198754;
            --warning: #ffc107;
            --shadow: rgba(0, 0, 0, 0.08);
            --radius: 6px;
        }

        [data-theme="dark"] {
            /* Dark Theme */
            --bg-body: #121212;
            --bg-card: #1e1e1e;
            --bg-input: #2d2d2d;
            --text-main: #e9ecef;
            --text-muted: #adb5bd;
            --border: #495057;
            --primary: #3d8bfd;
            --primary-hover: #5c9eff;
            --danger: #e35d6a;
            --success: #2ecc71;
            --warning: #ffca2c;
            --shadow: rgba(0, 0, 0, 0.3);
        }

        /* --- 2. Base Styles --- */
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            background-color: var(--bg-body);
            color: var(--text-main);
            margin: 0;
            padding: 20px;
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 100vh;
            transition: background-color 0.2s, color 0.2s;
        }

        a { color: var(--primary); text-decoration: none; }
        a:hover { text-decoration: underline; }

        /* --- 3. Layout Components --- */
        .header {
            width: 100%;
            max-width: 1100px;
            margin-bottom: 25px;
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            border-bottom: 1px solid var(--border);
            padding-bottom: 15px;
        }

        .header-content h1 { margin: 0 0 5px 0; font-size: 1.75rem; font-weight: 700; letter-spacing: -0.5px; }
        .header-content p { margin: 0; color: var(--text-muted); font-size: 0.95rem; max-width: 600px; line-height: 1.4; }

        .container {
            display: grid;
            grid-template-columns: 320px 1fr;
            gap: 20px;
            width: 100%;
            max-width: 1250px;
            align-items: start;
        }

        @media (max-width: 950px) {
            .container { grid-template-columns: 1fr; }
            .header { flex-direction: column; gap: 15px; }
        }

        /* --- 4. Sidebar / Controls --- */
        .sidebar {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        .card {
            background: var(--bg-card);
            border: 1px solid var(--border);
            border-radius: var(--radius);
            padding: 15px;
            box-shadow: 0 2px 8px var(--shadow);
            position: relative;
        }

        .card h3 {
            margin: 0 0 12px 0;
            font-size: 0.85rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            color: var(--primary);
            border-bottom: 1px solid var(--border);
            padding-bottom: 8px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .input-group { margin-bottom: 12px; }
        .input-group label {
            display: block;
            font-size: 0.8rem;
            font-weight: 600;
            margin-bottom: 5px;
            color: var(--text-main);
        }

        .row { display: flex; gap: 8px; }
        .row > * { flex: 1; }

        input[type="text"], input[type="number"], select {
            width: 100%;
            padding: 8px;
            background: var(--bg-input);
            border: 1px solid var(--border);
            color: var(--text-main);
            border-radius: 4px;
            font-size: 0.9rem;
            box-sizing: border-box;
            font-variant-numeric: tabular-nums;
        }
        
        input[type="number"]:focus, select:focus {
            outline: 2px solid var(--primary);
            border-color: transparent;
        }

        input[type="range"] {
            width: 100%;
            cursor: pointer;
            accent-color: var(--primary);
        }

        input[type="color"] {
            width: 100%;
            height: 35px;
            border: 1px solid var(--border);
            background: none;
            cursor: pointer;
            padding: 0;
            border-radius: 4px;
        }

        .checkbox-label {
            display: flex;
            align-items: center;
            font-size: 0.85rem;
            cursor: pointer;
            user-select: none;
        }
        .checkbox-label input { margin-right: 8px; width: auto; }

        /* --- 5. Buttons --- */
        button {
            padding: 10px 16px;
            border: none;
            border-radius: 4px;
            font-weight: 600;
            cursor: pointer;
            font-size: 0.9rem;
            transition: all 0.2s;
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 6px;
        }
        button:active { transform: translateY(1px); }
        button:hover { opacity: 0.95; }

        .btn-primary { background: var(--primary); color: white; width: 100%; margin-top: 5px; }
        .btn-secondary { background: var(--bg-input); border: 1px solid var(--border); color: var(--text-main); }
        .btn-success { background: var(--success); color: white; width: 100%; }
        .btn-warning { background: var(--warning); color: #000; width: 100%; }
        .btn-danger-outline { background: transparent; border: 1px solid var(--danger); color: var(--danger); width: 100%; }
        .btn-danger-outline:hover { background: var(--danger); color: white; }
        
        .btn-sm { padding: 4px 8px; font-size: 0.8rem; }
        .btn-icon { padding: 6px; aspect-ratio: 1; }

        /* Locked State for Button */
        .locked-active {
            background-color: var(--warning);
            color: black;
            border-color: var(--warning);
        }

        /* --- 6. Canvas Area --- */
        .canvas-wrapper {
            background: var(--bg-card);
            border: 1px solid var(--border);
            border-radius: var(--radius);
            padding: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 600px;
            height: calc(100vh - 150px);
            max-height: 800px;
            overflow: hidden; /* Canvas handles scroll/zoom internally mostly */
            position: relative;
        }
        
        /* Background variants */
        .bg-checkers {
            background-image:
                linear-gradient(45deg, #ccc 25%, transparent 25%),
                linear-gradient(-45deg, #ccc 25%, transparent 25%),
                linear-gradient(45deg, transparent 75%, #ccc 75%),
                linear-gradient(-45deg, transparent 75%, #ccc 75%);
            background-size: 20px 20px;
            background-position: 0 0, 0 10px, 10px -10px, -10px 0px;
        }
        .bg-white { background: #ffffff; }
        .bg-dark { background: #222222; }

        canvas {
            box-shadow: 0 10px 30px rgba(0,0,0,0.15);
            cursor: grab;
            max-width: 100%;
            max-height: 100%;
            image-rendering: auto; /* Default smooth */
        }
        
        canvas.pixelated {
            image-rendering: pixelated; /* Chrome/Opera */
            image-rendering: crisp-edges; /* Firefox */
        }
        
        canvas:active { cursor: grabbing; }
        canvas.locked { cursor: default; }

        .overlay-controls {
            position: absolute;
            top: 15px;
            right: 15px;
            display: flex;
            gap: 5px;
            background: var(--bg-card);
            padding: 5px;
            border-radius: 6px;
            border: 1px solid var(--border);
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }

        /* --- 7. Footer --- */
        .footer {
            margin-top: 40px;
            text-align: center;
            font-size: 0.85rem;
            color: var(--text-muted);
            border-top: 1px solid var(--border);
            padding-top: 20px;
            width: 100%;
            max-width: 1100px;
            padding-bottom: 20px;
        }
        .footer-links { display: flex; gap: 15px; justify-content: center; margin-top: 10px; flex-wrap: wrap;}

        .hidden { display: none; }
        
        .kbd-hint {
            display: inline-block;
            padding: 2px 6px;
            font-size: 0.7rem;
            font-family: monospace;
            background: var(--bg-input);
            border: 1px solid var(--border);
            border-radius: 4px;
            color: var(--text-muted);
        }
    </style>
</head>
<body>

    <div class="header">
        <div class="header-content">
            <h1>That Time I Generated a Grid on My Image</h1>
            <p>A lightweight, privacy-focused tool for artists. Overlay customizable grids, check composition with diagonals, and prepare references. Runs 100% in your browser.</p>
        </div>
        <div>
            <button class="btn-secondary" onclick="toggleTheme()">üåó Theme</button>
        </div>
    </div>

    <div class="container">
        <div class="sidebar">
            
            <div class="card">
                <h3>1. Source & Canvas</h3>
                <div class="input-group">
                    <label>Upload Image</label>
                    <input type="file" id="fileInput" accept="image/*">
                </div>
                
                <div class="input-group">
                    <label>Output Dimensions (px)</label>
                    <div class="row">
                        <input type="number" id="canvasW" placeholder="W" title="Width">
                        <input type="number" id="canvasH" placeholder="H" title="Height">
                    </div>
                    <button class="btn-secondary btn-sm" style="width:100%; margin-top:5px;" onclick="resetDimensionsToImage()">Reset to Image Size</button>
                </div>

                <div class="input-group">
                     <label>Canvas Background</label>
                     <div class="row">
                         <button class="btn-secondary btn-sm" onclick="setBg('bg-checkers')" title="Transparent">üèÅ</button>
                         <button class="btn-secondary btn-sm" onclick="setBg('bg-white')" title="White">‚¨ú</button>
                         <button class="btn-secondary btn-sm" onclick="setBg('bg-dark')" title="Dark">‚¨õ</button>
                     </div>
                </div>
            </div>

            <div class="card">
                <h3>2. Grid Configuration</h3>
                <div class="input-group">
                    <label>Calculation Mode</label>
                    <select id="gridMode">
                        <option value="count">Count (Rows/Cols)</option>
                        <option value="size">Cell Size (Pixels)</option>
                    </select>
                </div>

                <div id="mode-count" class="input-group row">
                    <div>
                        <label>Rows</label>
                        <input type="number" id="gridRows" value="8">
                    </div>
                    <div>
                        <label>Cols</label>
                        <input type="number" id="gridCols" value="8">
                    </div>
                </div>

                <div id="mode-size" class="input-group hidden">
                    <label>Cell Size (px)</label>
                    <input type="number" id="gridCellSize" value="100">
                </div>

                <div class="input-group row">
                    <div>
                        <label>Color</label>
                        <input type="color" id="gridColor" value="#ff0000">
                    </div>
                    <div>
                        <label>Thick (px)</label>
                        <input type="number" id="gridThickness" value="2" min="1" step="0.5">
                    </div>
                </div>
                
                <div class="input-group">
                    <label>Opacity: <span id="opacityVal">100%</span></label>
                    <input type="range" id="gridOpacity" min="0.1" max="1" step="0.05" value="1">
                </div>

                <div style="display:flex; flex-direction:column; gap:8px; margin-top:10px;">
                    <label class="checkbox-label">
                        <input type="checkbox" id="showLabels" checked>
                        Show Coordinates (A1, B2)
                    </label>
                    <label class="checkbox-label">
                        <input type="checkbox" id="showCenter">
                        Show Center Lines (Crosshair)
                    </label>
                    <label class="checkbox-label">
                        <input type="checkbox" id="showDiagonals">
                        Show Diagonals (X-Grid)
                    </label>
                </div>
            </div>

            <div class="card">
                <h3>3. Transform & Align</h3>
                
                <div class="row" style="margin-bottom:12px;">
                    <button id="lockBtn" class="btn-secondary" onclick="toggleLock()" title="Prevent accidental movement">
                        üîì Unlocked
                    </button>
                    <button id="pixelBtn" class="btn-secondary" onclick="togglePixelMode()" title="Toggle Nearest Neighbor scaling for pixel art">
                        üå´Ô∏è Smooth
                    </button>
                </div>

                <div class="input-group">
                    <label>Image Zoom (Scale)</label>
                    <input type="range" id="imgScale" min="0.1" max="10" step="0.01" value="1">
                </div>

                <div class="input-group">
                    <label>Grid Offset (X / Y) <span class="kbd-hint">Use Arrow Keys</span></label>
                    <div class="row">
                        <input type="number" id="gridOffsetX" value="0">
                        <input type="number" id="gridOffsetY" value="0">
                    </div>
                    <div class="row" style="margin-top:5px;">
                         <button class="btn-secondary btn-sm" onclick="centerImage()">Center Image</button>
                         <button class="btn-secondary btn-sm" onclick="resetOffsets()">Reset Offset</button>
                    </div>
                </div>
                
                <p style="font-size:0.75rem; color:var(--text-muted); margin-top:10px; line-height:1.3;">
                    <strong>Tip:</strong> Click the canvas and use Arrow Keys to nudge the grid by 1px.
                </p>
            </div>

            <div class="card">
                <button class="btn-success" onclick="downloadCanvas()">Download Result</button>
                <div style="margin-top:10px;">
                    <button class="btn-secondary" id="toggleGridBtn" style="width:100%" onclick="toggleGridVisible()">Hide Grid</button>
                </div>
                <button class="btn-danger-outline" style="margin-top:10px;" onclick="clearData()">Clear Saved Data</button>
            </div>

        </div>

        <div class="canvas-wrapper bg-checkers" id="canvasContainer" tabindex="0">
            <canvas id="mainCanvas"></canvas>
            
            <div class="overlay-controls">
                <button class="btn-secondary btn-icon" onclick="adjustZoom(0.1)" title="Zoom In">+</button>
                <button class="btn-secondary btn-icon" onclick="adjustZoom(-0.1)" title="Zoom Out">-</button>
                <button class="btn-secondary btn-icon" onclick="toggleLock()" id="overlayLockBtn" title="Lock/Unlock">üîì</button>
            </div>
        </div>
    </div>

    <div class="footer">
        <p><strong>Open Source Grid Generator</strong> developed by <a href="https://github.com/yigit-guven/" target="_blank">Yigit Guven</a>.</p>
        <div class="footer-links">
            <a href="https://github.com/yigit-guven/That-Time-I-Generated-a-Grid-on-My-Image" target="_blank">GitHub Repo</a>
            <span>‚Ä¢</span>
            <a href="https://github.com/yigit-guven/That-Time-I-Generated-a-Grid-on-My-Image/blob/main/LICENSE" target="_blank">MIT License</a>
            <span>‚Ä¢</span>
            <a href="https://github.com/yigit-guven/That-Time-I-Generated-a-Grid-on-My-Image/blob/main/SECURITY.md" target="_blank">Privacy Policy</a>
        </div>
        <p style="margin-top: 10px; opacity: 0.6; font-size: 0.75rem;">Images are processed locally in your browser. No data is sent to any server.</p>
    </div>

    <script>
        /**
         * APPLICATION STATE & CONSTANTS
         */
        const STORAGE_KEY = 'grid_gen_v3_state';
        const canvas = document.getElementById('mainCanvas');
        const ctx = canvas.getContext('2d');
        const container = document.getElementById('canvasContainer');
        
        // Default State
        let state = {
            // Canvas
            canvasW: 800,
            canvasH: 600,
            bgClass: 'bg-checkers',
            // Image
            imgData: null,
            imgX: 0,
            imgY: 0,
            scale: 1,
            pixelated: false,
            locked: false,
            // Grid
            gridMode: 'count', // 'count' or 'size'
            rows: 8,
            cols: 8,
            cellSize: 100,
            color: '#ff0000',
            thickness: 2,
            opacity: 1,
            gridOffsetX: 0,
            gridOffsetY: 0,
            // Visuals
            showLabels: true,
            showCenter: false,
            showDiagonals: false,
            isGridVisible: true
        };

        // Runtime variables
        let sourceImageObj = null;
        let isDragging = false;
        let lastMouseX = 0;
        let lastMouseY = 0;

        /**
         * INITIALIZATION
         */
        window.addEventListener('DOMContentLoaded', () => {
            loadState();
            setupEventListeners();
            
            if (!sourceImageObj) {
                draw();
                drawEmptyState();
            }
        });

        /**
         * EVENT LISTENERS
         */
        function setupEventListeners() {
            // File Upload
            document.getElementById('fileInput').addEventListener('change', handleImageUpload);
            
            // Mouse Interaction (Drag)
            container.addEventListener('mousedown', (e) => {
                // If interacting with canvas
                if(e.target !== canvas && e.target !== container) return;
                
                if (state.locked) return;
                
                isDragging = true;
                lastMouseX = e.clientX;
                lastMouseY = e.clientY;
                canvas.style.cursor = 'grabbing';
            });
            
            window.addEventListener('mouseup', () => {
                isDragging = false;
                canvas.style.cursor = state.locked ? 'default' : 'grab';
            });

            window.addEventListener('mousemove', (e) => {
                if (!isDragging || state.locked) return;
                e.preventDefault();
                
                const dx = e.clientX - lastMouseX;
                const dy = e.clientY - lastMouseY;
                
                state.imgX += dx;
                state.imgY += dy;
                
                lastMouseX = e.clientX;
                lastMouseY = e.clientY;
                
                requestAnimationFrame(draw);
                saveStateDebounced();
            });

            // Zoom (Wheel)
            container.addEventListener('wheel', (e) => {
                if (state.locked) return;
                e.preventDefault();
                const zoomSpeed = 0.001;
                const zoomFactor = -e.deltaY * zoomSpeed;
                
                let newScale = state.scale + (state.scale * zoomFactor);
                newScale = Math.max(0.01, Math.min(newScale, 20)); // Clamp

                // Zoom towards mouse
                const rect = canvas.getBoundingClientRect();
                const mouseX = e.clientX - rect.left;
                const mouseY = e.clientY - rect.top;

                state.imgX = mouseX - (mouseX - state.imgX) * (newScale / state.scale);
                state.imgY = mouseY - (mouseY - state.imgY) * (newScale / state.scale);
                
                state.scale = newScale;
                document.getElementById('imgScale').value = newScale;
                
                requestAnimationFrame(draw);
                saveStateDebounced();
            });

            // Keyboard Nudging (Arrow Keys)
            container.addEventListener('keydown', (e) => {
                // Only if focused on the container to avoid scrolling page
                if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'].includes(e.key)) {
                    e.preventDefault();
                    const shift = e.shiftKey ? 10 : 1; // Shift + Arrow = 10px
                    
                    if (e.key === 'ArrowUp') state.gridOffsetY -= shift;
                    if (e.key === 'ArrowDown') state.gridOffsetY += shift;
                    if (e.key === 'ArrowLeft') state.gridOffsetX -= shift;
                    if (e.key === 'ArrowRight') state.gridOffsetX += shift;
                    
                    updateUIFromState(); // Update inputs
                    draw();
                    saveStateDebounced();
                }
            });

            // Inputs
            bindInput('canvasW', 'value', (v) => { state.canvasW = parseInt(v) || 100; draw(); });
            bindInput('canvasH', 'value', (v) => { state.canvasH = parseInt(v) || 100; draw(); });
            bindInput('gridMode', 'value', (v) => { state.gridMode = v; toggleModeInputs(); draw(); });
            bindInput('gridRows', 'value', (v) => { state.rows = parseInt(v) || 1; draw(); });
            bindInput('gridCols', 'value', (v) => { state.cols = parseInt(v) || 1; draw(); });
            bindInput('gridCellSize', 'value', (v) => { state.cellSize = parseInt(v) || 10; draw(); });
            bindInput('gridColor', 'value', (v) => { state.color = v; draw(); });
            bindInput('gridThickness', 'value', (v) => { state.thickness = parseFloat(v); draw(); });
            bindInput('gridOpacity', 'value', (v) => { state.opacity = parseFloat(v); document.getElementById('opacityVal').innerText = Math.round(state.opacity * 100) + '%'; draw(); });
            
            bindInput('showLabels', 'checked', (v) => { state.showLabels = v; draw(); });
            bindInput('showCenter', 'checked', (v) => { state.showCenter = v; draw(); });
            bindInput('showDiagonals', 'checked', (v) => { state.showDiagonals = v; draw(); });
            
            bindInput('gridOffsetX', 'value', (v) => { state.gridOffsetX = parseInt(v) || 0; draw(); });
            bindInput('gridOffsetY', 'value', (v) => { state.gridOffsetY = parseInt(v) || 0; draw(); });

            bindInput('imgScale', 'value', (v) => {
                // Slider zoom logic (center based)
                const oldScale = state.scale;
                const newScale = parseFloat(v);
                const cx = state.canvasW / 2;
                const cy = state.canvasH / 2;
                state.imgX = cx - (cx - state.imgX) * (newScale / oldScale);
                state.imgY = cy - (cy - state.imgY) * (newScale / oldScale);
                state.scale = newScale;
                draw();
            });
        }

        function bindInput(id, prop, callback) {
            const el = document.getElementById(id);
            if(!el) return;
            el.addEventListener('input', (e) => {
                callback(el[prop]);
                saveStateDebounced();
            });
        }

        /**
         * CORE LOGIC
         */
        function handleImageUpload(e) {
            const file = e.target.files[0];
            if (!file) return;
            const reader = new FileReader();
            reader.onload = function(event) {
                const img = new Image();
                img.onload = function() {
                    sourceImageObj = img;
                    state.imgData = event.target.result;
                    // Reset to nice defaults on new image
                    state.canvasW = img.width;
                    state.canvasH = img.height;
                    state.imgX = 0;
                    state.imgY = 0;
                    state.scale = 1;
                    state.gridOffsetX = 0;
                    state.gridOffsetY = 0;
                    updateUIFromState();
                    draw();
                    saveState();
                }
                img.src = event.target.result;
            }
            reader.readAsDataURL(file);
        }

        function toggleModeInputs() {
            const countDiv = document.getElementById('mode-count');
            const sizeDiv = document.getElementById('mode-size');
            if (state.gridMode === 'count') {
                countDiv.classList.remove('hidden');
                sizeDiv.classList.add('hidden');
            } else {
                countDiv.classList.add('hidden');
                sizeDiv.classList.remove('hidden');
            }
        }

        function resetDimensionsToImage() {
            if (!sourceImageObj) return alert("Upload an image first.");
            state.canvasW = sourceImageObj.width;
            state.canvasH = sourceImageObj.height;
            state.imgX = 0;
            state.imgY = 0;
            state.scale = 1;
            updateUIFromState();
            draw();
            saveState();
        }

        function centerImage() {
            if (!sourceImageObj) return;
            const scaledW = sourceImageObj.width * state.scale;
            const scaledH = sourceImageObj.height * state.scale;
            state.imgX = (state.canvasW - scaledW) / 2;
            state.imgY = (state.canvasH - scaledH) / 2;
            draw();
            saveState();
        }
        
        function resetOffsets() {
            state.gridOffsetX = 0;
            state.gridOffsetY = 0;
            document.getElementById('gridOffsetX').value = 0;
            document.getElementById('gridOffsetY').value = 0;
            draw();
            saveState();
        }

        function toggleGridVisible() {
            state.isGridVisible = !state.isGridVisible;
            document.getElementById('toggleGridBtn').innerText = state.isGridVisible ? "Hide Grid" : "Show Grid";
            draw();
            saveState();
        }

        /* --- New QoL Functions --- */

        function toggleLock() {
            state.locked = !state.locked;
            const btn = document.getElementById('lockBtn');
            const overlayBtn = document.getElementById('overlayLockBtn');
            
            if (state.locked) {
                btn.innerHTML = "üîí Locked";
                btn.classList.add('locked-active');
                overlayBtn.innerHTML = "üîí";
                canvas.classList.add('locked');
            } else {
                btn.innerHTML = "üîì Unlocked";
                btn.classList.remove('locked-active');
                overlayBtn.innerHTML = "üîì";
                canvas.classList.remove('locked');
            }
            saveState();
        }

        function togglePixelMode() {
            state.pixelated = !state.pixelated;
            const btn = document.getElementById('pixelBtn');
            
            if (state.pixelated) {
                btn.innerHTML = "üëæ Pixelated";
                canvas.classList.add('pixelated');
            } else {
                btn.innerHTML = "üå´Ô∏è Smooth";
                canvas.classList.remove('pixelated');
            }
            draw(); // Redraw required for canvas context setting
            saveState();
        }

        function setBg(className) {
            state.bgClass = className;
            container.className = 'canvas-wrapper ' + className;
            saveState();
        }
        
        function adjustZoom(delta) {
            if(state.locked) return;
            let newScale = state.scale + delta;
            newScale = Math.max(0.01, Math.min(newScale, 20));
            
            // Zoom from center logic for button click
            const cx = state.canvasW / 2;
            const cy = state.canvasH / 2;
            state.imgX = cx - (cx - state.imgX) * (newScale / state.scale);
            state.imgY = cy - (cy - state.imgY) * (newScale / state.scale);
            
            state.scale = newScale;
            document.getElementById('imgScale').value = state.scale;
            draw();
            saveStateDebounced();
        }

        /**
         * DRAWING ENGINE
         */
        function draw() {
            canvas.width = state.canvasW;
            canvas.height = state.canvasH;
            
            // Crucial: Set smoothing based on state (must happen after resizing canvas)
            ctx.imageSmoothingEnabled = !state.pixelated;
            
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // 1. Draw Image
            if (sourceImageObj) {
                ctx.save();
                ctx.translate(state.imgX, state.imgY);
                ctx.scale(state.scale, state.scale);
                ctx.drawImage(sourceImageObj, 0, 0);
                ctx.restore();
            }

            // 2. Draw Grid
            if (state.isGridVisible) {
                drawGridLayer();
            }
        }
        
        function drawEmptyState() {
             ctx.fillStyle = localStorage.getItem('theme') === 'dark' ? '#555' : '#aaa';
             ctx.font = "bold 20px -apple-system, BlinkMacSystemFont, sans-serif";
             ctx.textAlign = "center";
             ctx.textBaseline = "middle";
             ctx.fillText("Drag & Drop or Upload Image", state.canvasW/2, state.canvasH/2);
             ctx.font = "14px sans-serif";
             ctx.fillText("(Click 'Upload Image' in sidebar)", state.canvasW/2, state.canvasH/2 + 30);
        }

        function drawGridLayer() {
            const hex = state.color;
            const r = parseInt(hex.substr(1,2), 16);
            const g = parseInt(hex.substr(3,2), 16);
            const b = parseInt(hex.substr(5,2), 16);
            
            ctx.strokeStyle = `rgba(${r}, ${g}, ${b}, ${state.opacity})`;
            ctx.fillStyle = `rgba(${r}, ${g}, ${b}, ${state.opacity})`;
            ctx.lineWidth = state.thickness;
            ctx.font = "bold 13px sans-serif";
            ctx.textBaseline = "top";

            // Calculate Step
            let stepX, stepY;
            if (state.gridMode === 'count') {
                stepX = state.canvasW / state.cols;
                stepY = state.canvasH / state.rows;
            } else {
                stepX = state.cellSize;
                stepY = state.cellSize;
            }

            // Calculate Start based on Offset
            // We draw slightly outside bounds to ensure coverage during offsets
            const startX = (state.gridOffsetX % stepX) - stepX; 
            const startY = (state.gridOffsetY % stepY) - stepY;

            // Draw Verticals
            let colIndexStart = Math.floor(-state.gridOffsetX / stepX) - 1; 
            let colCount = 0;
            
            // Standard Grid Lines
            ctx.beginPath();
            for (let x = startX; x <= state.canvasW + stepX; x += stepX) {
                if (x >= -state.thickness && x <= state.canvasW + state.thickness) {
                    ctx.moveTo(x, 0);
                    ctx.lineTo(x, state.canvasH);
                    
                    // Labels
                    if (state.showLabels && x < state.canvasW - 5) {
                        let labelIdx = colCount + colIndexStart + 1;
                        if (labelIdx >= 0) {
                            let char = getExcelColName(labelIdx); 
                            ctx.fillText(char, x + 4, 4);
                        }
                    }
                }
                colCount++;
            }
            
            // Horizontals
            let rowIndexStart = Math.floor(-state.gridOffsetY / stepY) - 1;
            let rowCount = 0;
            for (let y = startY; y <= state.canvasH + stepY; y += stepY) {
                if (y >= -state.thickness && y <= state.canvasH + state.thickness) {
                    ctx.moveTo(0, y);
                    ctx.lineTo(state.canvasW, y);
                    
                    if (state.showLabels && y < state.canvasH - 5) {
                        let labelNum = rowCount + rowIndexStart + 1;
                        if (labelNum >= 0) {
                            ctx.fillText(labelNum, 4, y + 4);
                        }
                    }
                }
                rowCount++;
            }
            ctx.stroke();

            // Draw Diagonals
            if (state.showDiagonals) {
                ctx.save();
                ctx.strokeStyle = `rgba(${r}, ${g}, ${b}, ${state.opacity * 0.6})`; // Slightly fainter
                ctx.lineWidth = state.thickness * 0.8;
                ctx.beginPath();
                
                // We iterate through cells to draw X in them
                // This is computationally heavier, so we optimize to visible area
                const cols = Math.ceil(state.canvasW / stepX) + 2;
                const rows = Math.ceil(state.canvasH / stepY) + 2;
                
                for(let c = 0; c < cols; c++) {
                    for(let r = 0; r < rows; r++) {
                        let cx = startX + (c * stepX);
                        let cy = startY + (r * stepY);
                        // Draw X
                        ctx.moveTo(cx, cy);
                        ctx.lineTo(cx + stepX, cy + stepY);
                        ctx.moveTo(cx + stepX, cy);
                        ctx.lineTo(cx, cy + stepY);
                    }
                }
                ctx.stroke();
                ctx.restore();
            }

            // Draw Center Lines (Crosshair)
            if (state.showCenter) {
                ctx.save();
                ctx.strokeStyle = `rgba(${r}, ${g}, ${b}, ${Math.min(1, state.opacity + 0.2)})`; // slightly stronger
                ctx.lineWidth = state.thickness * 1.5;
                ctx.setLineDash([10, 5]); // Dashed line for distinction
                ctx.beginPath();
                
                const centerX = (state.canvasW / 2) + state.gridOffsetX;
                const centerY = (state.canvasH / 2) + state.gridOffsetY;

                // Vertical Center
                ctx.moveTo(centerX, 0);
                ctx.lineTo(centerX, state.canvasH);

                // Horizontal Center
                ctx.moveTo(0, centerY);
                ctx.lineTo(state.canvasW, centerY);
                
                ctx.stroke();
                ctx.restore();
            }
        }

        function getExcelColName(n) {
            let s = "";
            while(n >= 0) {
                s = String.fromCharCode((n % 26) + 65) + s;
                n = Math.floor(n / 26) - 1;
            }
            return s;
        }

        /**
         * PERSISTENCE
         */
        let saveTimeout;
        function saveStateDebounced() {
            clearTimeout(saveTimeout);
            saveTimeout = setTimeout(saveState, 500);
        }

        function saveState() {
            try {
                localStorage.setItem(STORAGE_KEY, JSON.stringify(state));
            } catch (e) {
                // If image too big, save without image
                const liteState = { ...state, imgData: null };
                localStorage.setItem(STORAGE_KEY, JSON.stringify(liteState));
            }
        }

        function loadState() {
            const saved = localStorage.getItem(STORAGE_KEY);
            if (saved) {
                try {
                    const parsed = JSON.parse(saved);
                    state = { ...state, ...parsed };
                    
                    // UI Restore
                    updateUIFromState();
                    
                    // Specific Logic Restore
                    if(state.locked) {
                        // Manually toggle lock visual state without flipping the boolean
                        state.locked = !state.locked; // flip back to toggle correctly
                        toggleLock();
                    }
                    if(state.pixelated) {
                        state.pixelated = !state.pixelated;
                        togglePixelMode();
                    }
                    if(state.bgClass) {
                        setBg(state.bgClass);
                    }

                    if (state.imgData) {
                        const img = new Image();
                        img.onload = () => {
                            sourceImageObj = img;
                            draw();
                        };
                        img.src = state.imgData;
                    }
                } catch(e) {
                    console.error(e);
                }
            }
        }

        function updateUIFromState() {
            document.getElementById('canvasW').value = state.canvasW;
            document.getElementById('canvasH').value = state.canvasH;
            document.getElementById('gridMode').value = state.gridMode;
            document.getElementById('gridRows').value = state.rows;
            document.getElementById('gridCols').value = state.cols;
            document.getElementById('gridCellSize').value = state.cellSize;
            document.getElementById('gridColor').value = state.color;
            document.getElementById('gridThickness').value = state.thickness;
            document.getElementById('gridOpacity').value = state.opacity;
            
            document.getElementById('showLabels').checked = state.showLabels;
            document.getElementById('showCenter').checked = state.showCenter;
            document.getElementById('showDiagonals').checked = state.showDiagonals;
            
            document.getElementById('gridOffsetX').value = state.gridOffsetX;
            document.getElementById('gridOffsetY').value = state.gridOffsetY;
            document.getElementById('imgScale').value = state.scale;
            document.getElementById('opacityVal').innerText = Math.round(state.opacity * 100) + '%';
            document.getElementById('toggleGridBtn').innerText = state.isGridVisible ? "Hide Grid" : "Show Grid";
            
            toggleModeInputs();
        }

        function clearData() {
            if(confirm("Reset all settings and clear image?")) {
                localStorage.removeItem(STORAGE_KEY);
                location.reload();
            }
        }

        function downloadCanvas() {
            const link = document.createElement('a');
            link.download = 'grid-image.png';
            link.href = canvas.toDataURL('image/png');
            link.click();
        }

        function toggleTheme() {
            const html = document.documentElement;
            const next = html.getAttribute('data-theme') === 'dark' ? 'light' : 'dark';
            html.setAttribute('data-theme', next);
            localStorage.setItem('theme', next);
            draw(); 
            if(!sourceImageObj) drawEmptyState();
        }
    </script>
</body>
</html>