<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>That Time I Generated a Grid on My Image</title>
    
    <script>
        (function() {
            const savedTheme = localStorage.getItem('theme');
            const prefersDark = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches;
            if (savedTheme === 'dark' || (!savedTheme && prefersDark)) {
                document.documentElement.setAttribute('data-theme', 'dark');
            }
        })();
    </script>

    <style>
        /* --- CORE VARS --- */
        :root {
            --bg-app: #f0f2f5;
            --bg-panel: #ffffff;
            --bg-input: #f8f9fa;
            --text-main: #2d3436;
            --text-muted: #636e72;
            --border: #dfe6e9;
            --primary: #6c5ce7;
            --primary-hover: #5849c2;
            --accent: #00b894;
            --danger: #d63031;
            --radius: 6px;
            --shadow: 0 4px 6px rgba(0,0,0,0.05);
            --header-height: 50px;
        }

        [data-theme="dark"] {
            --bg-app: #1e1e1e;
            --bg-panel: #252526;
            --bg-input: #333333;
            --text-main: #dfe6e9;
            --text-muted: #b2bec3;
            --border: #3f3f46;
            --primary: #74b9ff;
            --primary-hover: #0984e3;
            --accent: #55efc4;
            --danger: #ff7675;
            --shadow: 0 4px 6px rgba(0,0,0,0.3);
        }

        /* --- RESET & LAYOUT --- */
        body {
            margin: 0;
            padding: 0;
            font-family: 'Segoe UI', Inter, system-ui, sans-serif;
            background-color: var(--bg-app);
            color: var(--text-main);
            height: 100vh;
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        * { box-sizing: border-box; }

        /* --- APP STRUCTURE --- */
        .app-header {
            height: var(--header-height);
            background: var(--bg-panel);
            border-bottom: 1px solid var(--border);
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0 20px;
            z-index: 10;
        }

        .app-header h1 {
            font-size: 1.1rem;
            margin: 0;
            font-weight: 700;
            color: var(--primary);
            letter-spacing: -0.5px;
        }

        .app-body {
            flex: 1;
            display: flex;
            overflow: hidden;
        }

        /* --- SIDEBAR --- */
        .sidebar {
            width: 320px;
            background: var(--bg-panel);
            border-right: 1px solid var(--border);
            display: flex;
            flex-direction: column;
            overflow-y: auto;
            overflow-x: hidden;
            z-index: 5;
        }

        .sidebar-content {
            padding: 15px;
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        /* --- PANELS & ACCORDIONS --- */
        .panel {
            border: 1px solid var(--border);
            border-radius: var(--radius);
            background: var(--bg-panel);
            overflow: hidden;
        }

        .panel-header {
            padding: 10px 12px;
            background: var(--bg-input);
            font-size: 0.85rem;
            font-weight: 600;
            border-bottom: 1px solid var(--border);
            display: flex;
            justify-content: space-between;
            align-items: center;
            cursor: pointer;
            user-select: none;
        }
        
        .panel-header:hover { background: var(--border); }
        .panel-header::after { content: 'â–¼'; font-size: 0.7rem; opacity: 0.5; }
        .panel.collapsed .panel-header::after { content: 'â—€'; }
        .panel.collapsed .panel-body { display: none; }

        .panel-body { padding: 12px; }

        /* --- CONTROLS --- */
        .control-group { margin-bottom: 10px; }
        .control-group:last-child { margin-bottom: 0; }
        
        label {
            display: block;
            font-size: 0.75rem;
            font-weight: 600;
            margin-bottom: 4px;
            color: var(--text-muted);
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .row { display: flex; gap: 8px; align-items: center; }
        .col { flex: 1; }

        input[type="text"], input[type="number"], select {
            width: 100%;
            padding: 6px 8px;
            background: var(--bg-input);
            border: 1px solid var(--border);
            color: var(--text-main);
            border-radius: 4px;
            font-size: 0.85rem;
        }

        input[type="range"] {
            width: 100%;
            accent-color: var(--primary);
            height: 4px;
            margin: 8px 0;
        }

        input[type="color"] {
            -webkit-appearance: none;
            width: 100%;
            height: 30px;
            border: 1px solid var(--border);
            padding: 0;
            background: none;
            border-radius: 4px;
            cursor: pointer;
        }
        input[type="color"]::-webkit-color-swatch-wrapper { padding: 2px; }
        input[type="color"]::-webkit-color-swatch { border-radius: 2px; border: none; }

        /* --- BUTTONS --- */
        .btn {
            border: none;
            padding: 8px 12px;
            border-radius: 4px;
            font-size: 0.85rem;
            font-weight: 600;
            cursor: pointer;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            gap: 6px;
            transition: all 0.2s;
            text-align: center;
        }

        .btn-block { width: 100%; display: flex; }
        .btn-sm { padding: 4px 8px; font-size: 0.75rem; }

        .btn-primary { background: var(--primary); color: white; }
        .btn-primary:hover { background: var(--primary-hover); }

        .btn-secondary { background: var(--bg-input); border: 1px solid var(--border); color: var(--text-main); }
        .btn-secondary:hover { border-color: var(--text-muted); }

        .btn-accent { background: var(--accent); color: #000; }
        .btn-danger { background: transparent; border: 1px solid var(--danger); color: var(--danger); }
        .btn-danger:hover { background: var(--danger); color: white; }

        .btn-toggle { opacity: 0.5; }
        .btn-toggle.active { opacity: 1; border-color: var(--primary); background: rgba(108, 92, 231, 0.1); color: var(--primary); }

        /* --- VIEWPORT --- */
        .viewport {
            flex: 1;
            position: relative;
            background-color: #2d2d2d; /* Always dark for viewport area */
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
            background-image:
                linear-gradient(45deg, #333 25%, transparent 25%),
                linear-gradient(-45deg, #333 25%, transparent 25%),
                linear-gradient(45deg, transparent 75%, #333 75%),
                linear-gradient(-45deg, transparent 75%, #333 75%);
            background-size: 20px 20px;
            background-position: 0 0, 0 10px, 10px -10px, -10px 0px;
        }

        canvas {
            box-shadow: 0 20px 50px rgba(0,0,0,0.5);
            cursor: grab;
            max-width: none; /* Allow canvas to exceed viewport for zoom */
        }
        canvas:active { cursor: grabbing; }

        /* --- FLOATING CONTROLS --- */
        .floating-toolbar {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: var(--bg-panel);
            padding: 6px;
            border-radius: 50px;
            display: flex;
            gap: 5px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.2);
            border: 1px solid var(--border);
        }

        .drop-zone {
            position: absolute;
            top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(108, 92, 231, 0.8);
            color: white;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 2rem;
            font-weight: bold;
            z-index: 100;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.2s;
        }
        .drop-zone.active { opacity: 1; pointer-events: all; }

        /* --- FOOTER --- */
        .footer-sidebar {
            margin-top: auto;
            padding: 15px;
            border-top: 1px solid var(--border);
            font-size: 0.7rem;
            color: var(--text-muted);
            text-align: center;
            background: var(--bg-input);
        }
        .footer-sidebar a { color: var(--primary); text-decoration: none; }
        .footer-sidebar a:hover { text-decoration: underline; }

        .hidden { display: none !important; }
    </style>
</head>
<body>

    <div id="dropZone" class="drop-zone">Drop Image Here</div>

    <header class="app-header">
        <div style="display:flex; align-items:center; gap:10px;">
            <span style="font-size:1.5rem;"></span>
            <div>
                <h1>That Time I Generated a Grid on My Image</h1>
                <span style="font-size:0.7rem; color:var(--text-muted);">A lightweight, client-side tool to overlay customizable grids on images. Built with HTML5 and the Canvas API; runs entirely in the browser.</span>
            </div>
        </div>
        <div class="row">
            <button class="btn btn-secondary btn-sm" onclick="triggerUpload()">ðŸ“‚ Open</button>
            <input type="file" id="fileInput" accept="image/*" class="hidden">
            <button class="btn btn-secondary btn-sm" onclick="toggleTheme()">ðŸŒ—</button>
        </div>
    </header>

    <div class="app-body">
        
        <aside class="sidebar">
            <div class="sidebar-content">

                <div class="panel">
                    <div class="panel-header" onclick="togglePanel(this)">Image & Adjustments</div>
                    <div class="panel-body">
                        <div class="control-group">
                            <label>Transform</label>
                            <div class="row">
                                <button class="btn btn-secondary btn-sm col" onclick="rotateImage(90)">â†» 90Â°</button>
                                <button class="btn btn-secondary btn-sm col" onclick="flipImage('h')">â†” Flip H</button>
                                <button class="btn btn-secondary btn-sm col" onclick="flipImage('v')">â†• Flip V</button>
                            </div>
                        </div>

                        <div class="control-group">
                            <label>Filters</label>
                            <div class="row" style="margin-bottom:5px;">
                                <span style="font-size:0.7rem; width: 60px;">Grayscale</span>
                                <input type="range" id="filterGray" min="0" max="100" value="0">
                            </div>
                            <div class="row" style="margin-bottom:5px;">
                                <span style="font-size:0.7rem; width: 60px;">Contrast</span>
                                <input type="range" id="filterContrast" min="50" max="150" value="100">
                            </div>
                            <div class="row">
                                <span style="font-size:0.7rem; width: 60px;">Bright</span>
                                <input type="range" id="filterBrightness" min="50" max="150" value="100">
                            </div>
                            <button class="btn btn-secondary btn-sm btn-block" style="margin-top:5px;" onclick="resetFilters()">Reset Filters</button>
                        </div>
                    </div>
                </div>

                <div class="panel">
                    <div class="panel-header" onclick="togglePanel(this)">Main Grid</div>
                    <div class="panel-body">
                        <div class="control-group">
                            <div class="row">
                                <select id="gridType" class="col" onchange="updateUIFromState()">
                                    <option value="standard">Standard (Square)</option>
                                    <option value="isometric">Isometric (30Â°)</option>
                                </select>
                            </div>
                        </div>

                        <div class="control-group">
                            <label>Mode</label>
                            <div class="row">
                                <button class="btn btn-secondary btn-sm col active" id="btnModeCount" onclick="setGridMode('count')">Count (R/C)</button>
                                <button class="btn btn-secondary btn-sm col" id="btnModeSize" onclick="setGridMode('size')">Px Size</button>
                            </div>
                        </div>

                        <div id="inputsCount" class="control-group row">
                            <div class="col">
                                <label>Rows</label>
                                <input type="number" id="gridRows" value="8" min="1">
                            </div>
                            <div class="col">
                                <label>Cols</label>
                                <input type="number" id="gridCols" value="8" min="1">
                            </div>
                        </div>

                        <div id="inputsSize" class="control-group hidden">
                            <label>Cell Size (px)</label>
                            <input type="number" id="gridCellSize" value="100" min="2">
                        </div>

                        <div class="control-group row">
                            <div class="col">
                                <label>Color</label>
                                <input type="color" id="gridColor" value="#ff0000">
                            </div>
                            <div class="col">
                                <label>Thickness</label>
                                <input type="number" id="gridThick" value="2" step="0.5" min="0.5">
                            </div>
                        </div>
                        
                        <div class="control-group">
                             <label>Opacity</label>
                             <input type="range" id="gridOpacity" min="0" max="1" step="0.1" value="1">
                        </div>

                        <div class="control-group">
                            <label style="display:flex; align-items:center;">
                                <input type="checkbox" id="showLabels" checked style="margin-right:5px;"> Show Labels (A1, B2)
                            </label>
                        </div>
                    </div>
                </div>

                <div class="panel">
                    <div class="panel-header" onclick="togglePanel(this)">Sub-Divisions</div>
                    <div class="panel-body">
                         <div class="control-group">
                            <label style="display:flex; align-items:center;">
                                <input type="checkbox" id="enableSubGrid" onchange="toggleSubInputs()"> Enable Sub-Grid
                            </label>
                         </div>
                         <div id="subGridControls" class="hidden">
                             <div class="control-group">
                                 <label>Divisions per Cell</label>
                                 <input type="number" id="subGridDivs" value="4" min="2">
                             </div>
                             <div class="control-group row">
                                <div class="col">
                                    <label>Color</label>
                                    <input type="color" id="subGridColor" value="#ffffff">
                                </div>
                                <div class="col">
                                    <label>Opacity</label>
                                    <input type="number" id="subGridOpacity" value="0.5" step="0.1" max="1" min="0">
                                </div>
                            </div>
                         </div>
                    </div>
                </div>

                <div class="panel">
                    <div class="panel-header" onclick="togglePanel(this)">Guides & Overlays</div>
                    <div class="panel-body">
                        <div class="control-group">
                            <button class="btn btn-secondary btn-sm btn-block btn-toggle" id="toggleCenter" onclick="toggleOverlay('center')">Center Crosshair</button>
                        </div>
                        <div class="control-group">
                            <button class="btn btn-secondary btn-sm btn-block btn-toggle" id="toggleThirds" onclick="toggleOverlay('thirds')">Rule of Thirds</button>
                        </div>
                        <div class="control-group">
                            <button class="btn btn-secondary btn-sm btn-block btn-toggle" id="toggleDiagonal" onclick="toggleOverlay('diagonal')">Diagonals (X)</button>
                        </div>
                        <div class="control-group">
                            <button class="btn btn-secondary btn-sm btn-block btn-toggle" id="toggleGolden" onclick="toggleOverlay('golden')">Golden Ratio</button>
                        </div>
                    </div>
                </div>

                <div class="panel">
                    <div class="panel-body">
                         <div class="control-group">
                            <label>Offset X/Y (Arrow Keys)</label>
                            <div class="row">
                                <input type="number" id="offsetX" value="0">
                                <input type="number" id="offsetY" value="0">
                            </div>
                         </div>
                         <button class="btn btn-primary btn-block" onclick="downloadImage()">Download Result</button>
                         <button class="btn btn-danger btn-block" style="margin-top:10px;" onclick="clearAll()">Reset All</button>
                    </div>
                </div>

            </div>
            
            <div class="footer-sidebar">
                <p><strong>That Time I Generated a Grid on My Image</strong><br>by <a href="https://github.com/yigit-guven/" target="_blank">Yigit Guven</a></p>
                <div style="margin-top:5px;">
                     <a href="https://github.com/yigit-guven/That-Time-I-Generated-a-Grid-on-My-Image" target="_blank">GitHub</a> â€¢ 
                     <a href="https://github.com/yigit-guven/That-Time-I-Generated-a-Grid-on-My-Image/blob/main/LICENSE" target="_blank">MIT License</a> â€¢
                     <a href="https://github.com/yigit-guven/That-Time-I-Generated-a-Grid-on-My-Image/blob/main/SECURITY.md" target="_blank">Privacy & Security Policy</a>
                </div>
                <p style="margin-top:8px; opacity:0.7;">Images processed locally.</p>
            </div>
        </aside>

        <main class="viewport" id="viewport">
            <canvas id="mainCanvas"></canvas>
            
            <div class="floating-toolbar">
                <button class="btn btn-secondary btn-sm" onclick="adjustZoom(-0.1)">-</button>
                <button class="btn btn-secondary btn-sm" id="zoomDisplay" onclick="resetZoom()">100%</button>
                <button class="btn btn-secondary btn-sm" onclick="adjustZoom(0.1)">+</button>
                <div style="width:1px; background:var(--border); margin:0 5px;"></div>
                <button class="btn btn-secondary btn-sm" id="btnSmooth" onclick="toggleSmooth()">Smooth</button>
                <button class="btn btn-secondary btn-sm" id="btnLock" onclick="toggleLock()">ðŸ”“</button>
            </div>
        </main>
    </div>

    <script>
        /**
         * STATE MANAGEMENT
         */
        const STORAGE_KEY = 'grid_gen_pro_v1';
        const canvas = document.getElementById('mainCanvas');
        const ctx = canvas.getContext('2d');
        const viewport = document.getElementById('viewport');

        let state = {
            // Image Data
            imgData: null,
            imgName: 'image',
            imgW: 800,
            imgH: 600,
            
            // Transform & Filters
            zoom: 1,
            panX: 0,
            panY: 0,
            rotation: 0, // 0, 90, 180, 270
            flipH: false,
            flipV: false,
            filterGray: 0,
            filterContrast: 100,
            filterBrightness: 100,
            
            // Grid Settings
            gridType: 'standard', // standard, isometric
            gridMode: 'count', // count, size
            gridRows: 8,
            gridCols: 8,
            gridSize: 100,
            gridColor: '#ff0000',
            gridThick: 2,
            gridOpacity: 1,
            gridOffsetX: 0,
            gridOffsetY: 0,
            showLabels: true,

            // Sub Grid
            subGridEnabled: false,
            subGridDivs: 4,
            subGridColor: '#ffffff',
            subGridOpacity: 0.5,

            // Overlays
            overlayCenter: false,
            overlayThirds: false,
            overlayDiagonal: false,
            overlayGolden: false,

            // Viewport
            isPixelated: false, // false = smooth, true = nearest-neighbor
            isLocked: false
        };

        let sourceImage = null;
        let isDragging = false;
        let lastMouseX = 0, lastMouseY = 0;

        /**
         * INITIALIZATION
         */
        window.addEventListener('DOMContentLoaded', () => {
            loadState();
            setupEvents();
            if(!sourceImage) drawEmptyCanvas();
            else draw();
        });

        function setupEvents() {
            // File Inputs
            document.getElementById('fileInput').addEventListener('change', handleUpload);
            
            // Drag & Drop (Global)
            window.addEventListener('dragover', e => { e.preventDefault(); document.getElementById('dropZone').classList.add('active'); });
            window.addEventListener('dragleave', e => { if(e.target.id === 'dropZone') document.getElementById('dropZone').classList.remove('active'); });
            window.addEventListener('drop', handleDrop);

            // Paste
            window.addEventListener('paste', handlePaste);

            // Canvas Interaction
            viewport.addEventListener('mousedown', startPan);
            window.addEventListener('mousemove', doPan);
            window.addEventListener('mouseup', endPan);
            viewport.addEventListener('wheel', handleZoom, {passive: false});

            // Keyboard Shortcuts
            window.addEventListener('keydown', handleKeys);

            // UI Bindings
            bindInputs();
        }

        /**
         * INPUT BINDING UTILITY
         * Automatically binds inputs to state and redraws
         */
        function bindInputs() {
            const bindings = [
                { id: 'gridRows', prop: 'gridRows', type: 'int' },
                { id: 'gridCols', prop: 'gridCols', type: 'int' },
                { id: 'gridCellSize', prop: 'gridSize', type: 'int' },
                { id: 'gridColor', prop: 'gridColor' },
                { id: 'gridThick', prop: 'gridThick', type: 'float' },
                { id: 'gridOpacity', prop: 'gridOpacity', type: 'float' },
                { id: 'gridType', prop: 'gridType' },
                
                { id: 'offsetX', prop: 'gridOffsetX', type: 'int' },
                { id: 'offsetY', prop: 'gridOffsetY', type: 'int' },
                
                { id: 'enableSubGrid', prop: 'subGridEnabled', type: 'bool' },
                { id: 'subGridDivs', prop: 'subGridDivs', type: 'int' },
                { id: 'subGridColor', prop: 'subGridColor' },
                { id: 'subGridOpacity', prop: 'subGridOpacity', type: 'float' },

                { id: 'showLabels', prop: 'showLabels', type: 'bool' },

                { id: 'filterGray', prop: 'filterGray', type: 'int' },
                { id: 'filterContrast', prop: 'filterContrast', type: 'int' },
                { id: 'filterBrightness', prop: 'filterBrightness', type: 'int' }
            ];

            bindings.forEach(b => {
                const el = document.getElementById(b.id);
                if(!el) return;
                
                // Set initial value
                if(b.type === 'bool') el.checked = state[b.prop];
                else el.value = state[b.prop];

                // Listen
                el.addEventListener(b.type === 'bool' || b.id === 'gridType' ? 'change' : 'input', () => {
                    let val = el.value;
                    if(b.type === 'int') val = parseInt(val) || 0;
                    if(b.type === 'float') val = parseFloat(val) || 0;
                    if(b.type === 'bool') val = el.checked;
                    
                    state[b.prop] = val;
                    if(b.id === 'gridType') updateUIFromState();
                    draw();
                    saveState();
                });
            });
        }

        /**
         * IMAGE HANDLING
         */
        function triggerUpload() { document.getElementById('fileInput').click(); }

        function handleUpload(e) { processFile(e.target.files[0]); }

        function handleDrop(e) {
            e.preventDefault();
            document.getElementById('dropZone').classList.remove('active');
            if (e.dataTransfer.files.length) processFile(e.dataTransfer.files[0]);
        }

        function handlePaste(e) {
            const items = (e.clipboardData || e.originalEvent.clipboardData).items;
            for (let i = 0; i < items.length; i++) {
                if (items[i].type.indexOf('image') !== -1) {
                    processFile(items[i].getAsFile());
                    break;
                }
            }
        }

        function processFile(file) {
            if (!file) return;
            const reader = new FileReader();
            reader.onload = (e) => {
                const img = new Image();
                img.onload = () => {
                    sourceImage = img;
                    state.imgData = e.target.result;
                    state.imgName = file.name.split('.')[0];
                    state.imgW = img.width;
                    state.imgH = img.height;
                    
                    // Reset View
                    state.zoom = 1;
                    if(img.width > viewport.clientWidth) state.zoom = (viewport.clientWidth - 40) / img.width;
                    centerImage();
                    resetFilters();
                    
                    updateUIFromState();
                    draw();
                    saveState();
                };
                img.src = e.target.result;
            };
            reader.readAsDataURL(file);
        }

        /**
         * CANVAS MANIPULATION
         */
        function startPan(e) {
            if(state.isLocked) return;
            isDragging = true;
            lastMouseX = e.clientX;
            lastMouseY = e.clientY;
            canvas.style.cursor = 'grabbing';
        }

        function doPan(e) {
            if (!isDragging) return;
            e.preventDefault();
            const dx = e.clientX - lastMouseX;
            const dy = e.clientY - lastMouseY;
            state.panX += dx;
            state.panY += dy;
            lastMouseX = e.clientX;
            lastMouseY = e.clientY;
            canvas.style.transform = `translate(${state.panX}px, ${state.panY}px)`;
        }

        function endPan() {
            isDragging = false;
            canvas.style.cursor = state.isLocked ? 'default' : 'grab';
            saveState(); // Save pos
        }

        function handleZoom(e) {
            if(state.isLocked) return;
            e.preventDefault();
            const delta = e.deltaY > 0 ? -0.1 : 0.1;
            adjustZoom(delta);
        }

        function adjustZoom(delta) {
            state.zoom = Math.max(0.1, Math.min(20, state.zoom + delta));
            state.zoom = Math.round(state.zoom * 100) / 100;
            draw();
            saveState();
        }

        function resetZoom() { state.zoom = 1; centerImage(); draw(); }
        
        function centerImage() {
            // Note: panX/Y corresponds to CSS transform, not internal canvas coords
            state.panX = 0; 
            state.panY = 0;
            canvas.style.transform = `translate(0px, 0px)`;
        }

        function handleKeys(e) {
            // Nudge grid
            if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'].includes(e.key)) {
                // If user is focused on an input, don't hijack
                if(document.activeElement.tagName === 'INPUT') return;
                
                e.preventDefault();
                const shift = e.shiftKey ? 10 : 1;
                if(e.key === 'ArrowLeft') state.gridOffsetX -= shift;
                if(e.key === 'ArrowRight') state.gridOffsetX += shift;
                if(e.key === 'ArrowUp') state.gridOffsetY -= shift;
                if(e.key === 'ArrowDown') state.gridOffsetY += shift;
                
                document.getElementById('offsetX').value = state.gridOffsetX;
                document.getElementById('offsetY').value = state.gridOffsetY;
                draw();
            }
            // Paste shortcut is handled by window listener
        }

        /**
         * TRANSFORMS & FILTERS
         */
        function rotateImage(deg) {
            state.rotation = (state.rotation + deg) % 360;
            draw();
            saveState();
        }
        function flipImage(dir) {
            if(dir === 'h') state.flipH = !state.flipH;
            if(dir === 'v') state.flipV = !state.flipV;
            draw();
            saveState();
        }
        function resetFilters() {
            state.filterGray = 0;
            state.filterContrast = 100;
            state.filterBrightness = 100;
            state.rotation = 0;
            state.flipH = false;
            state.flipV = false;
            
            // Update UI inputs manually
            document.getElementById('filterGray').value = 0;
            document.getElementById('filterContrast').value = 100;
            document.getElementById('filterBrightness').value = 100;
            
            draw();
            saveState();
        }

        /**
         * DRAWING ENGINE
         */
        function drawEmptyCanvas() {
            canvas.width = 800;
            canvas.height = 600;
            ctx.fillStyle = '#2d2d2d';
            ctx.fillRect(0,0,800,600);
            ctx.fillStyle = '#666';
            ctx.font = 'bold 20px sans-serif';
            ctx.textAlign = 'center';
            ctx.fillText('Drag Image Here or Click Open', 400, 300);
            updateZoomDisplay();
        }

        function draw() {
            if (!sourceImage) return;

            // 1. Setup Canvas Dimensions (Apply Zoom here for resolution, OR use CSS for zoom)
            // Strategy: Canvas = Actual Image Size. CSS = Visual Scaling.
            // However, to include grid lines clearly at low resolution (pixel art), we draw grid ON the canvas.
            // If we use CSS for zoom, grid lines scale with it. This is usually desired.
            
            // Check Rotation dimensions
            let drawW = state.imgW;
            let drawH = state.imgH;
            if (state.rotation === 90 || state.rotation === 270) {
                drawW = state.imgH;
                drawH = state.imgW;
            }

            canvas.width = drawW;
            canvas.height = drawH;
            
            // Apply Visual Zoom via CSS
            canvas.style.width = (drawW * state.zoom) + 'px';
            canvas.style.height = (drawH * state.zoom) + 'px';
            canvas.style.imageRendering = state.isPixelated ? 'pixelated' : 'auto';

            updateZoomDisplay();

            ctx.save();

            // 2. Draw Image with Transforms & Filters
            ctx.filter = `grayscale(${state.filterGray}%) contrast(${state.filterContrast}%) brightness(${state.filterBrightness}%)`;
            
            // Handle Rotation & Flip context
            ctx.translate(canvas.width/2, canvas.height/2);
            ctx.rotate(state.rotation * Math.PI / 180);
            ctx.scale(state.flipH ? -1 : 1, state.flipV ? -1 : 1);
            ctx.drawImage(sourceImage, -state.imgW/2, -state.imgH/2);
            
            ctx.restore(); // Filters/Transforms removed for grid drawing

            // 3. Draw Grid
            if(state.gridType === 'isometric') drawIsometricGrid();
            else drawStandardGrid();

            // 4. Draw Overlays
            drawOverlays();
        }

        function drawStandardGrid() {
            const w = canvas.width;
            const h = canvas.height;
            
            let stepX, stepY;

            if (state.gridMode === 'count') {
                stepX = w / state.gridRows; // Wait, rows usually divide Height? Yes.
                // In UI: Rows cuts Y axis, Cols cuts X axis.
                stepX = w / state.gridCols;
                stepY = h / state.gridRows;
            } else {
                stepX = state.gridSize;
                stepY = state.gridSize;
            }
            
            // Clamp min size
            if(stepX < 2) stepX = 2; 
            if(stepY < 2) stepY = 2;

            const startX = (state.gridOffsetX % stepX) - stepX;
            const startY = (state.gridOffsetY % stepY) - stepY;

            ctx.lineWidth = state.gridThick;
            ctx.strokeStyle = state.gridColor;
            ctx.globalAlpha = state.gridOpacity;
            ctx.beginPath();

            // Verticals
            let colIdx = Math.floor(-state.gridOffsetX / stepX) - 1;
            for (let x = startX; x <= w + stepX; x += stepX) {
                ctx.moveTo(x, 0); ctx.lineTo(x, h);
                drawLabel(x + 4, 4, getExcelCol(colIdx + 1), 'h');
                colIdx++;
            }
            // Horizontals
            let rowIdx = Math.floor(-state.gridOffsetY / stepY) - 1;
            for (let y = startY; y <= h + stepY; y += stepY) {
                ctx.moveTo(0, y); ctx.lineTo(w, y);
                drawLabel(4, y + 4, (rowIdx + 1).toString(), 'v');
                rowIdx++;
            }
            ctx.stroke();

            // SUB GRID
            if(state.subGridEnabled && state.subGridDivs > 1) {
                ctx.beginPath();
                ctx.strokeStyle = state.subGridColor;
                ctx.globalAlpha = state.subGridOpacity;
                ctx.lineWidth = Math.max(0.5, state.gridThick / 2);
                
                const subX = stepX / state.subGridDivs;
                const subY = stepY / state.subGridDivs;

                // Optimization: Don't draw if subgrid is < 3px
                if(subX > 3) {
                    for (let x = startX; x <= w + stepX; x += subX) {
                        // Skip main lines
                        if(Math.abs((x - startX) % stepX) < 0.1) continue; 
                        ctx.moveTo(x, 0); ctx.lineTo(x, h);
                    }
                    for (let y = startY; y <= h + stepY; y += subY) {
                         if(Math.abs((y - startY) % stepY) < 0.1) continue; 
                        ctx.moveTo(0, y); ctx.lineTo(w, y);
                    }
                }
                ctx.stroke();
            }

            ctx.globalAlpha = 1;
        }

        function drawIsometricGrid() {
            // Isometric is best defined by cell size (triangle side length)
            // We force gridMode to 'size' visually in UI, but handle logic here
            const size = state.gridSize;
            const h = size * Math.sin(Math.PI/3); // height of triangle row
            
            ctx.lineWidth = state.gridThick;
            ctx.strokeStyle = state.gridColor;
            ctx.globalAlpha = state.gridOpacity;
            ctx.beginPath();

            const w = canvas.width;
            const H = canvas.height;
            
            // Simply drawing lines at 30 deg and 150 deg + horizontals? 
            // True isometric grid: Vertical lines? No, usually 30/30 grid.
            // Let's do standard Isometric (Diamond) grid
            
            // 1. Lines at 30 deg
            // y = tan(30)x + c  => y = 0.577x + c
            const tan30 = 0.577;
            const step = size; 
            
            // To cover canvas with angled lines, we need a large range
            const maxDim = Math.max(w, H) * 2;
            
            for(let k = -maxDim; k < maxDim; k+= step) {
                // / Direction
                ctx.moveTo(0, k);
                ctx.lineTo(maxDim, k - (maxDim * tan30));
                
                // \ Direction
                ctx.moveTo(0, k);
                ctx.lineTo(maxDim, k + (maxDim * tan30));
            }
            
            ctx.stroke();
            ctx.globalAlpha = 1;
        }

        function drawOverlays() {
            const w = canvas.width;
            const h = canvas.height;
            ctx.globalAlpha = 0.8;
            ctx.lineWidth = 2;

            if(state.overlayCenter) {
                ctx.strokeStyle = '#00ff00';
                ctx.setLineDash([10, 5]);
                ctx.beginPath();
                ctx.moveTo(w/2, 0); ctx.lineTo(w/2, h);
                ctx.moveTo(0, h/2); ctx.lineTo(w, h/2);
                ctx.stroke();
                ctx.setLineDash([]);
            }

            if(state.overlayDiagonal) {
                ctx.strokeStyle = '#ff00ff';
                ctx.beginPath();
                ctx.moveTo(0,0); ctx.lineTo(w,h);
                ctx.moveTo(w,0); ctx.lineTo(0,h);
                ctx.stroke();
            }

            if(state.overlayThirds) {
                ctx.strokeStyle = '#00ffff';
                ctx.beginPath();
                ctx.moveTo(w/3, 0); ctx.lineTo(w/3, h);
                ctx.moveTo(w*2/3, 0); ctx.lineTo(w*2/3, h);
                ctx.moveTo(0, h/3); ctx.lineTo(w, h/3);
                ctx.moveTo(0, h*2/3); ctx.lineTo(w, h*2/3);
                ctx.stroke();
            }
            
            if(state.overlayGolden) {
                 ctx.strokeStyle = '#ffd700';
                 const phi = 0.618;
                 const x1 = w * (1-phi);
                 const x2 = w * phi;
                 const y1 = h * (1-phi);
                 const y2 = h * phi;
                 ctx.beginPath();
                 ctx.moveTo(x1, 0); ctx.lineTo(x1, h);
                 ctx.moveTo(x2, 0); ctx.lineTo(x2, h);
                 ctx.moveTo(0, y1); ctx.lineTo(w, y1);
                 ctx.moveTo(0, y2); ctx.lineTo(w, y2);
                 ctx.stroke();
            }

            ctx.globalAlpha = 1;
        }

        function drawLabel(x, y, text, axis) {
            if(!state.showLabels) return;
            ctx.fillStyle = state.gridColor;
            ctx.font = 'bold 12px sans-serif';
            ctx.textBaseline = 'top';
            // Only draw if within bounds
            if(x > 0 && x < canvas.width && y > 0 && y < canvas.height) {
                // Background for readability
                ctx.globalAlpha = 0.8;
                const width = ctx.measureText(text).width;
                ctx.fillStyle = state.gridColor; // Use grid color for text
                // Check contrast or just use shadow?
                ctx.shadowColor = "white";
                ctx.shadowBlur = 2;
                ctx.fillText(text, x, y);
                ctx.shadowBlur = 0;
            }
        }

        function getExcelCol(n) {
            let s = "";
            while(n >= 0) {
                s = String.fromCharCode((n % 26) + 65) + s;
                n = Math.floor(n / 26) - 1;
            }
            return s;
        }

        /**
         * UI HELPERS
         */
        function updateUIFromState() {
            // Toggle Mode Buttons
            document.getElementById('btnModeCount').classList.toggle('active', state.gridMode === 'count');
            document.getElementById('btnModeSize').classList.toggle('active', state.gridMode === 'size');
            
            // Toggle Inputs
            if(state.gridType === 'isometric') {
                // Iso only works well with Size
                document.getElementById('inputsCount').classList.add('hidden');
                document.getElementById('inputsSize').classList.remove('hidden');
                document.getElementById('btnModeCount').classList.add('hidden');
                document.getElementById('btnModeSize').classList.add('hidden');
            } else {
                document.getElementById('btnModeCount').classList.remove('hidden');
                document.getElementById('btnModeSize').classList.remove('hidden');
                if (state.gridMode === 'count') {
                    document.getElementById('inputsCount').classList.remove('hidden');
                    document.getElementById('inputsSize').classList.add('hidden');
                } else {
                    document.getElementById('inputsCount').classList.add('hidden');
                    document.getElementById('inputsSize').classList.remove('hidden');
                }
            }

            // Buttons visual state
            document.getElementById('btnSmooth').innerText = state.isPixelated ? "ðŸ‘¾ Pixel" : "ðŸŒ«ï¸ Smooth";
            document.getElementById('btnLock').innerText = state.isLocked ? "ðŸ”’" : "ðŸ”“";
            
            // Toggle Overlays buttons
            document.getElementById('toggleCenter').classList.toggle('active', state.overlayCenter);
            document.getElementById('toggleThirds').classList.toggle('active', state.overlayThirds);
            document.getElementById('toggleDiagonal').classList.toggle('active', state.overlayDiagonal);
            document.getElementById('toggleGolden').classList.toggle('active', state.overlayGolden);

            toggleSubInputs();
        }

        function setGridMode(mode) {
            state.gridMode = mode;
            updateUIFromState();
            draw();
            saveState();
        }

        function togglePanel(header) {
            header.parentElement.classList.toggle('collapsed');
        }

        function toggleSubInputs() {
            const el = document.getElementById('subGridControls');
            state.subGridEnabled ? el.classList.remove('hidden') : el.classList.add('hidden');
        }

        function toggleOverlay(type) {
            if(type === 'center') state.overlayCenter = !state.overlayCenter;
            if(type === 'thirds') state.overlayThirds = !state.overlayThirds;
            if(type === 'diagonal') state.overlayDiagonal = !state.overlayDiagonal;
            if(type === 'golden') state.overlayGolden = !state.overlayGolden;
            updateUIFromState();
            draw();
            saveState();
        }

        function toggleSmooth() {
            state.isPixelated = !state.isPixelated;
            draw();
            saveState();
            updateUIFromState();
        }

        function toggleLock() {
            state.isLocked = !state.isLocked;
            endPan(); // reset cursor
            updateUIFromState();
        }

        function updateZoomDisplay() {
            document.getElementById('zoomDisplay').innerText = Math.round(state.zoom * 100) + "%";
        }

        function downloadImage() {
            if(!sourceImage) return;
            const link = document.createElement('a');
            link.download = `${state.imgName}_grid.png`;
            link.href = canvas.toDataURL('image/png');
            link.click();
        }

        function clearAll() {
            if(confirm("Clear image and reset all settings?")) {
                localStorage.removeItem(STORAGE_KEY);
                location.reload();
            }
        }

        /**
         * THEME & PERSISTENCE
         */
        function toggleTheme() {
            const html = document.documentElement;
            const current = html.getAttribute('data-theme');
            const next = current === 'dark' ? 'light' : 'dark';
            html.setAttribute('data-theme', next);
            localStorage.setItem('theme', next);
        }

        function saveState() {
            // Debounce handled naturally by JS execution loop usually fine for this scale,
            // but for base64 image, we should be careful.
            // We save everything EXCEPT imgData if it's huge, but for now let's try.
            try {
                // If image is too big, localstorage fails. 
                const safeState = {...state};
                // We keep image in memory, but maybe not save it every millisecond
                localStorage.setItem(STORAGE_KEY, JSON.stringify(safeState));
            } catch(e) {
                console.log("Storage full or error", e);
                // Fallback: save settings without image
                const noImg = {...state, imgData: null};
                localStorage.setItem(STORAGE_KEY, JSON.stringify(noImg));
            }
        }

        function loadState() {
            const saved = localStorage.getItem(STORAGE_KEY);
            if(saved) {
                try {
                    const parsed = JSON.parse(saved);
                    state = {...state, ...parsed};
                    updateUIFromState();
                    if(state.imgData) {
                        const img = new Image();
                        img.onload = () => {
                            sourceImage = img;
                            state.imgW = img.width;
                            state.imgH = img.height;
                            draw();
                        };
                        img.src = state.imgData;
                    }
                } catch(e) { console.error(e); }
            }
        }

    </script>
</body>
</html>