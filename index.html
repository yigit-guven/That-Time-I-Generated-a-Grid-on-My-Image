<!DOCTYPE html>
<html lang="en" data-theme="dark">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>That Time I Generated a Grid on My Image - Ultimate Professional Edition</title>
    
    <style>
        /* ============================================
         * 1. THEME SYSTEM & CORE VARIABLES
         * ============================================ */
        :root {
            /* Theme Presets */
            --theme-dark-bg-app: #121212;
            --theme-dark-bg-panel: #1e1e1e;
            --theme-dark-bg-header: #181818;
            --theme-dark-bg-input: #2c2c2c;
            --theme-dark-bg-active: #3a3a3a;
            --theme-dark-text-main: #e0e0e0;
            --theme-dark-text-muted: #9e9e9e;
            --theme-dark-border: #333333;
            --theme-dark-primary: #ffffff;
            --theme-dark-primary-hover: #f0f0f0;
            --theme-dark-accent: #4fc3f7;
            --theme-dark-danger: #ff5252;
            --theme-dark-success: #00c853;
            --theme-dark-warning: #ff9800;
            --theme-dark-info: #2196f3;
            
            --theme-light-bg-app: #f5f5f5;
            --theme-light-bg-panel: #ffffff;
            --theme-light-bg-header: #ffffff;
            --theme-light-bg-input: #f0f0f0;
            --theme-light-bg-active: #e0e0e0;
            --theme-light-text-main: #212121;
            --theme-light-text-muted: #757575;
            --theme-light-border: #e0e0e0;
            --theme-light-primary: #000000;
            --theme-light-primary-hover: #333333;
            --theme-light-accent: #0277bd;
            --theme-light-danger: #d32f2f;
            --theme-light-success: #388e3c;
            --theme-light-warning: #f57c00;
            --theme-light-info: #1976d2;
            
            --theme-ocean-bg-app: #0a192f;
            --theme-ocean-bg-panel: #112240;
            --theme-ocean-bg-header: #0a192f;
            --theme-ocean-bg-input: #233554;
            --theme-ocean-bg-active: #2d4263;
            --theme-ocean-text-main: #ccd6f6;
            --theme-ocean-text-muted: #8892b0;
            --theme-ocean-border: #233554;
            --theme-ocean-primary: #64ffda;
            --theme-ocean-primary-hover: #52d1b2;
            --theme-ocean-accent: #57cbff;
            --theme-ocean-danger: #ff6b6b;
            --theme-ocean-success: #4ecdc4;
            --theme-ocean-warning: #ffd166;
            --theme-ocean-info: #118ab2;
            
            --theme-autumn-bg-app: #2d1b1b;
            --theme-autumn-bg-panel: #3a2424;
            --theme-autumn-bg-header: #2d1b1b;
            --theme-autumn-bg-input: #4a2f2f;
            --theme-autumn-bg-active: #5a3a3a;
            --theme-autumn-text-main: #f0e6d2;
            --theme-autumn-text-muted: #b8a692;
            --theme-autumn-border: #4a2f2f;
            --theme-autumn-primary: #ff9a3c;
            --theme-autumn-primary-hover: #ff8a1c;
            --theme-autumn-accent: #ff6b6b;
            --theme-autumn-danger: #e74c3c;
            --theme-autumn-success: #9bca3e;
            --theme-autumn-warning: #f39c12;
            --theme-autumn-info: #3498db;
            
            --theme-matrix-bg-app: #0a0a0a;
            --theme-matrix-bg-panel: #111111;
            --theme-matrix-bg-header: #0a0a0a;
            --theme-matrix-bg-input: #222222;
            --theme-matrix-bg-active: #333333;
            --theme-matrix-text-main: #00ff41;
            --theme-matrix-text-muted: #008f11;
            --theme-matrix-border: #003b00;
            --theme-matrix-primary: #00ff41;
            --theme-matrix-primary-hover: #00cc34;
            --theme-matrix-accent: #00ff9d;
            --theme-matrix-danger: #ff0040;
            --theme-matrix-success: #00ff41;
            --theme-matrix-warning: #ffff00;
            --theme-matrix-info: #00ffff;
            
            /* Current Theme Variables (will be set by JavaScript) */
            --bg-app: var(--theme-dark-bg-app);
            --bg-panel: var(--theme-dark-bg-panel);
            --bg-header: var(--theme-dark-bg-header);
            --bg-input: var(--theme-dark-bg-input);
            --bg-active: var(--theme-dark-bg-active);
            --text-main: var(--theme-dark-text-main);
            --text-muted: var(--theme-dark-text-muted);
            --border: var(--theme-dark-border);
            --primary: var(--theme-dark-primary);
            --primary-hover: var(--theme-dark-primary-hover);
            --accent: var(--theme-dark-accent);
            --danger: var(--theme-dark-danger);
            --success: var(--theme-dark-success);
            --warning: var(--theme-dark-warning);
            --info: var(--theme-dark-info);
            
            --font-ui: 'Segoe UI', Inter, Roboto, Helvetica, Arial, sans-serif;
            --font-mono: 'JetBrains Mono', 'Cascadia Code', 'Fira Code', monospace;
            --header-height: 55px;
            --sidebar-width: 380px;
            --transition: 0.2s cubic-bezier(0.4, 0, 0.2, 1);
            
            /* Elevation Shadows */
            --shadow-sm: 0 2px 4px rgba(0,0,0,0.1);
            --shadow-md: 0 4px 8px rgba(0,0,0,0.15);
            --shadow-lg: 0 8px 16px rgba(0,0,0,0.2);
            --shadow-xl: 0 12px 24px rgba(0,0,0,0.25);
            --shadow-xxl: 0 20px 40px rgba(0,0,0,0.3);
            
            /* Border Radius */
            --radius-sm: 4px;
            --radius-md: 8px;
            --radius-lg: 12px;
            --radius-xl: 16px;
            --radius-round: 50%;
        }

        /* Theme Overrides */
        [data-theme="dark"] {
            --bg-app: var(--theme-dark-bg-app);
            --bg-panel: var(--theme-dark-bg-panel);
            --bg-header: var(--theme-dark-bg-header);
            --bg-input: var(--theme-dark-bg-input);
            --bg-active: var(--theme-dark-bg-active);
            --text-main: var(--theme-dark-text-main);
            --text-muted: var(--theme-dark-text-muted);
            --border: var(--theme-dark-border);
            --primary: var(--theme-dark-primary);
            --primary-hover: var(--theme-dark-primary-hover);
            --accent: var(--theme-dark-accent);
            --danger: var(--theme-dark-danger);
            --success: var(--theme-dark-success);
            --warning: var(--theme-dark-warning);
            --info: var(--theme-dark-info);
        }

        [data-theme="light"] {
            --bg-app: var(--theme-light-bg-app);
            --bg-panel: var(--theme-light-bg-panel);
            --bg-header: var(--theme-light-bg-header);
            --bg-input: var(--theme-light-bg-input);
            --bg-active: var(--theme-light-bg-active);
            --text-main: var(--theme-light-text-main);
            --text-muted: var(--theme-light-text-muted);
            --border: var(--theme-light-border);
            --primary: var(--theme-light-primary);
            --primary-hover: var(--theme-dark-primary-hover);
            --accent: var(--theme-light-accent);
            --danger: var(--theme-light-danger);
            --success: var(--theme-light-success);
            --warning: var(--theme-light-warning);
            --info: var(--theme-light-info);
        }

        [data-theme="ocean"] {
            --bg-app: var(--theme-ocean-bg-app);
            --bg-panel: var(--theme-ocean-bg-panel);
            --bg-header: var(--theme-ocean-bg-header);
            --bg-input: var(--theme-ocean-bg-input);
            --bg-active: var(--theme-ocean-bg-active);
            --text-main: var(--theme-ocean-text-main);
            --text-muted: var(--theme-ocean-text-muted);
            --border: var(--theme-ocean-border);
            --primary: var(--theme-ocean-primary);
            --primary-hover: var(--theme-ocean-primary-hover);
            --accent: var(--theme-ocean-accent);
            --danger: var(--theme-ocean-danger);
            --success: var(--theme-ocean-success);
            --warning: var(--theme-ocean-warning);
            --info: var(--theme-ocean-info);
        }

        [data-theme="autumn"] {
            --bg-app: var(--theme-autumn-bg-app);
            --bg-panel: var(--theme-autumn-bg-panel);
            --bg-header: var(--theme-autumn-bg-header);
            --bg-input: var(--theme-autumn-bg-input);
            --bg-active: var(--theme-autumn-bg-active);
            --text-main: var(--theme-autumn-text-main);
            --text-muted: var(--theme-autumn-text-muted);
            --border: var(--theme-autumn-border);
            --primary: var(--theme-autumn-primary);
            --primary-hover: var(--theme-autumn-primary-hover);
            --accent: var(--theme-autumn-accent);
            --danger: var(--theme-autumn-danger);
            --success: var(--theme-autumn-success);
            --warning: var(--theme-autumn-warning);
            --info: var(--theme-autumn-info);
        }

        [data-theme="matrix"] {
            --bg-app: var(--theme-matrix-bg-app);
            --bg-panel: var(--theme-matrix-bg-panel);
            --bg-header: var(--theme-matrix-bg-header);
            --bg-input: var(--theme-matrix-bg-input);
            --bg-active: var(--theme-matrix-bg-active);
            --text-main: var(--theme-matrix-text-main);
            --text-muted: var(--theme-matrix-text-muted);
            --border: var(--theme-matrix-border);
            --primary: var(--theme-matrix-primary);
            --primary-hover: var(--theme-matrix-primary-hover);
            --accent: var(--theme-matrix-accent);
            --danger: var(--theme-matrix-danger);
            --success: var(--theme-matrix-success);
            --warning: var(--theme-matrix-warning);
            --info: var(--theme-matrix-info);
        }

        /* High Contrast Mode */
        [data-theme="high-contrast"] {
            --bg-app: #000000;
            --bg-panel: #000000;
            --bg-header: #000000;
            --bg-input: #000000;
            --bg-active: #333333;
            --text-main: #ffffff;
            --text-muted: #cccccc;
            --border: #ffffff;
            --primary: #ffffff;
            --primary-hover: #cccccc;
            --accent: #ffff00;
            --danger: #ff0000;
            --success: #00ff00;
            --warning: #ffa500;
            --info: #00ffff;
        }

        /* ============================================
         * 2. GLOBAL RESET & BASE STYLES
         * ============================================ */
        body, html {
            margin: 0;
            padding: 0;
            height: 100%;
            width: 100%;
            overflow: hidden;
            background: var(--bg-app);
            color: var(--text-main);
            font-family: var(--font-ui);
            font-size: 14px;
            line-height: 1.5;
            transition: background-color 0.3s ease, color 0.3s ease;
        }

        * {
            box-sizing: border-box;
            outline: none;
        }

        /* Scrollbars */
        ::-webkit-scrollbar {
            width: 10px;
            height: 10px;
        }

        ::-webkit-scrollbar-track {
            background: var(--bg-input);
            border-radius: var(--radius-sm);
        }

        ::-webkit-scrollbar-thumb {
            background: var(--border);
            border-radius: var(--radius-sm);
            border: 2px solid var(--bg-input);
        }

        ::-webkit-scrollbar-thumb:hover {
            background: var(--text-muted);
        }

        /* Selection */
        ::selection {
            background: var(--accent);
            color: var(--bg-app);
        }

        /* ============================================
         * 3. LAYOUT STRUCTURE
         * ============================================ */
        .app-container {
            display: flex;
            flex-direction: column;
            height: 100vh;
            overflow: hidden;
        }

        /* Header */
        .app-header {
            height: var(--header-height);
            background: var(--bg-header);
            border-bottom: 2px solid var(--border);
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0 20px;
            z-index: 100;
            box-shadow: var(--shadow-md);
        }

        .branding h1 {
            font-size: 1.2rem;
            margin: 0;
            font-weight: 700;
            color: var(--primary);
            letter-spacing: -0.5px;
        }

        .branding small {
            font-size: 0.75rem;
            color: var(--text-muted);
            display: block;
            font-weight: 400;
        }

        .branding-subtitle {
            font-size: 0.65rem;
            color: var(--accent);
            display: block;
            margin-top: 2px;
            font-style: italic;
        }

        .header-controls {
            display: flex;
            gap: 12px;
            align-items: center;
        }

        /* Main Body */
        .app-body {
            flex: 1;
            display: flex;
            overflow: hidden;
            position: relative;
        }

        /* Sidebar */
        .sidebar {
            width: var(--sidebar-width);
            background: var(--bg-panel);
            border-right: 1px solid var(--border);
            display: flex;
            flex-direction: column;
            z-index: 90;
            transition: transform 0.3s var(--transition);
            box-shadow: var(--shadow-lg);
        }

        .sidebar.collapsed {
            transform: translateX(-100%);
            margin-right: calc(var(--sidebar-width) * -1);
        }

        /* Sidebar Tabs */
        .sidebar-tabs {
            display: flex;
            border-bottom: 1px solid var(--border);
            background: var(--bg-header);
            padding: 0 10px;
        }

        .tab-btn {
            flex: 1;
            padding: 14px 0;
            background: transparent;
            border: none;
            color: var(--text-muted);
            font-size: 0.85rem;
            font-weight: 600;
            cursor: pointer;
            border-bottom: 3px solid transparent;
            transition: all var(--transition);
            position: relative;
            overflow: hidden;
        }

        .tab-btn:hover {
            color: var(--text-main);
            background: rgba(255,255,255,0.05);
        }

        .tab-btn.active {
            color: var(--primary);
            border-bottom-color: var(--primary);
            background: linear-gradient(rgba(255,255,255,0.05), transparent);
        }

        .tab-btn::after {
            content: '';
            position: absolute;
            bottom: 0;
            left: 50%;
            width: 0;
            height: 2px;
            background: var(--accent);
            transition: all var(--transition);
            transform: translateX(-50%);
        }

        .tab-btn:hover::after {
            width: 60%;
        }

        .sidebar-scroll {
            flex: 1;
            overflow-y: auto;
            padding: 20px;
            scroll-behavior: smooth;
        }

        .tab-content {
            display: none;
            animation: fadeIn 0.3s var(--transition);
        }

        .tab-content.active {
            display: block;
        }

        @keyframes fadeIn {
            from {
                opacity: 0;
                transform: translateY(10px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        /* Footer in Sidebar */
        .sidebar-footer {
            padding: 15px 20px;
            border-top: 1px solid var(--border);
            background: var(--bg-header);
            font-size: 0.7rem;
            color: var(--text-muted);
            text-align: center;
            line-height: 1.4;
        }

        .sidebar-footer a {
            color: var(--primary);
            text-decoration: none;
            font-weight: 600;
            transition: color var(--transition);
            position: relative;
        }

        .sidebar-footer a:hover {
            color: var(--accent);
            text-decoration: underline;
        }

        .sidebar-footer a::after {
            content: 'â†—';
            font-size: 0.6em;
            margin-left: 2px;
            opacity: 0.7;
        }

        /* Viewport */
        .viewport {
            flex: 1;
            position: relative;
            background-color: var(--bg-app);
            overflow: hidden;
            display: flex;
            justify-content: center;
            align-items: center;
            background-image:
                linear-gradient(45deg, var(--border) 25%, transparent 25%),
                linear-gradient(-45deg, var(--border) 25%, transparent 25%),
                linear-gradient(45deg, transparent 75%, var(--border) 75%),
                linear-gradient(-45deg, transparent 75%, var(--border) 75%);
            background-size: 24px 24px;
            background-position: 0 0, 0 12px, 12px -12px, -12px 0px;
            cursor: grab;
            transition: background-color 0.3s ease;
        }

        .viewport:active {
            cursor: grabbing;
        }

        /* Cursor States */
        .viewport.mode-pan { cursor: grab; }
        .viewport.mode-draw { cursor: crosshair; }
        .viewport.mode-crop { cursor: crosshair; }
        .viewport.mode-measure { cursor: crosshair; }
        .viewport.mode-text { cursor: text; }
        .viewport.mode-shape { cursor: crosshair; }

        canvas {
            box-shadow: var(--shadow-xl);
            transform-origin: center;
            image-rendering: auto;
            max-width: 100%;
            max-height: 100%;
            transition: box-shadow 0.3s ease;
        }

        canvas:hover {
            box-shadow: var(--shadow-xxl);
        }

        /* ============================================
         * 4. UI COMPONENTS
         * ============================================ */

        /* Control Groups */
        .control-group {
            margin-bottom: 20px;
            background: var(--bg-input);
            padding: 16px;
            border-radius: var(--radius-md);
            border: 1px solid var(--border);
            transition: all var(--transition);
            position: relative;
            overflow: hidden;
        }

        .control-group:hover {
            border-color: var(--accent);
            box-shadow: var(--shadow-sm);
        }

        .control-group-title {
            font-size: 0.8rem;
            font-weight: 700;
            color: var(--text-main);
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 12px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding-bottom: 8px;
            border-bottom: 1px solid var(--border);
        }

        .control-group-title .icon {
            font-size: 1rem;
            opacity: 0.7;
        }

        /* Input Layouts */
        .row {
            display: flex;
            gap: 10px;
            align-items: center;
            margin-bottom: 12px;
        }

        .row:last-child {
            margin-bottom: 0;
        }

        .col {
            flex: 1;
        }

        .col-2 { flex: 2; }
        .col-3 { flex: 3; }
        .col-auto { flex: 0 0 auto; }

        /* Labels */
        label {
            display: block;
            margin-bottom: 6px;
            font-size: 0.85rem;
            color: var(--text-main);
            font-weight: 500;
        }

        .label-inline {
            display: flex;
            align-items: center;
            margin-bottom: 0;
        }

        /* Inputs */
        input[type="text"],
        input[type="number"],
        input[type="url"],
        input[type="email"],
        select,
        textarea {
            width: 100%;
            padding: 10px 12px;
            background: var(--bg-panel);
            border: 2px solid var(--border);
            color: var(--text-main);
            border-radius: var(--radius-sm);
            font-size: 0.9rem;
            font-family: var(--font-ui);
            transition: all var(--transition);
        }

        input:focus,
        select:focus,
        textarea:focus {
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(255,255,255,0.1);
            outline: none;
        }

        input[type="color"] {
            width: 100%;
            height: 40px;
            border: 2px solid var(--border);
            border-radius: var(--radius-sm);
            cursor: pointer;
            background: var(--bg-panel);
            padding: 2px;
        }

        input[type="color"]::-webkit-color-swatch-wrapper {
            padding: 0;
        }

        input[type="color"]::-webkit-color-swatch {
            border: none;
            border-radius: var(--radius-sm);
        }

        /* Custom Checkbox & Radio */
        .chk-label {
            display: flex;
            align-items: center;
            cursor: pointer;
            font-size: 0.9rem;
            user-select: none;
            padding: 8px 0;
            border-radius: var(--radius-sm);
            transition: background-color var(--transition);
        }

        .chk-label:hover {
            background: rgba(255,255,255,0.05);
        }

        .chk-label input {
            margin-right: 10px;
            width: 18px;
            height: 18px;
            cursor: pointer;
        }

        /* Custom Radio Group */
        .radio-group {
            display: flex;
            gap: 8px;
            margin-bottom: 12px;
        }

        .radio-label {
            flex: 1;
            text-align: center;
            padding: 10px;
            background: var(--bg-input);
            border: 2px solid var(--border);
            border-radius: var(--radius-sm);
            cursor: pointer;
            transition: all var(--transition);
            font-size: 0.85rem;
        }

        .radio-label:hover {
            border-color: var(--accent);
            background: var(--bg-active);
        }

        .radio-label.active {
            border-color: var(--primary);
            background: var(--bg-active);
            color: var(--primary);
            font-weight: 600;
        }

        .radio-label input {
            display: none;
        }

        /* Sliders */
        .slider-container {
            position: relative;
            margin: 15px 0;
        }

        input[type="range"] {
            -webkit-appearance: none;
            width: 100%;
            height: 6px;
            background: var(--border);
            border-radius: 3px;
            margin: 15px 0;
            position: relative;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 20px;
            height: 20px;
            border-radius: var(--radius-round);
            background: var(--primary);
            cursor: pointer;
            border: 3px solid var(--bg-panel);
            box-shadow: var(--shadow-md);
            transition: all var(--transition);
        }

        input[type="range"]::-webkit-slider-thumb:hover {
            transform: scale(1.2);
            background: var(--primary-hover);
        }

        .slider-value {
            position: absolute;
            right: 0;
            top: -5px;
            background: var(--bg-input);
            padding: 2px 8px;
            border-radius: var(--radius-sm);
            font-size: 0.8rem;
            font-family: var(--font-mono);
            border: 1px solid var(--border);
        }

        /* Buttons */
        .btn {
            border: none;
            padding: 10px 16px;
            border-radius: var(--radius-sm);
            font-size: 0.85rem;
            font-weight: 600;
            cursor: pointer;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            transition: all var(--transition);
            color: var(--text-main);
            background: var(--bg-input);
            border: 2px solid var(--border);
            position: relative;
            overflow: hidden;
        }

        .btn::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.1), transparent);
            transition: left 0.5s ease;
        }

        .btn:hover::before {
            left: 100%;
        }

        .btn:hover {
            background: var(--bg-active);
            border-color: var(--accent);
            transform: translateY(-1px);
            box-shadow: var(--shadow-md);
        }

        .btn:active {
            transform: translateY(0);
            box-shadow: var(--shadow-sm);
        }

        .btn-sm {
            padding: 8px 12px;
            font-size: 0.8rem;
        }

        .btn-xs {
            padding: 4px 8px;
            font-size: 0.75rem;
        }

        .btn-lg {
            padding: 14px 20px;
            font-size: 0.9rem;
        }

        .btn-primary {
            background: var(--primary);
            color: var(--bg-app);
            border-color: var(--primary);
        }

        .btn-primary:hover {
            background: var(--primary-hover);
            border-color: var(--primary-hover);
        }

        .btn-secondary {
            background: var(--bg-input);
            color: var(--text-main);
            border-color: var(--accent);
        }

        .btn-accent {
            background: var(--accent);
            color: var(--bg-app);
            border-color: var(--accent);
        }

        .btn-danger {
            background: var(--danger);
            color: white;
            border-color: var(--danger);
        }

        .btn-danger:hover {
            background: #ff3333;
            border-color: #ff3333;
        }

        .btn-success {
            background: var(--success);
            color: white;
            border-color: var(--success);
        }

        .btn-warning {
            background: var(--warning);
            color: var(--bg-app);
            border-color: var(--warning);
        }

        .btn-info {
            background: var(--info);
            color: white;
            border-color: var(--info);
        }

        .btn-block {
            width: 100%;
        }

        .btn.active {
            background: rgba(255,255,255,0.15);
            color: var(--primary);
            border-color: var(--primary);
            box-shadow: inset 0 2px 4px rgba(0,0,0,0.2);
        }

        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none !important;
        }

        .btn-icon {
            padding: 8px;
            width: 36px;
            height: 36px;
            border-radius: var(--radius-round);
        }

        /* Badges */
        .badge {
            display: inline-block;
            padding: 4px 8px;
            font-size: 0.7rem;
            font-weight: 600;
            border-radius: var(--radius-sm);
            background: var(--bg-input);
            color: var(--text-muted);
            border: 1px solid var(--border);
        }

        .badge-primary {
            background: var(--primary);
            color: var(--bg-app);
        }

        .badge-accent {
            background: var(--accent);
            color: var(--bg-app);
        }

        .badge-danger {
            background: var(--danger);
            color: white;
        }

        /* Cards */
        .card {
            background: var(--bg-input);
            border: 1px solid var(--border);
            border-radius: var(--radius-md);
            padding: 16px;
            margin-bottom: 12px;
            transition: all var(--transition);
        }

        .card:hover {
            border-color: var(--accent);
            box-shadow: var(--shadow-sm);
        }

        .card-title {
            font-size: 0.9rem;
            font-weight: 600;
            color: var(--text-main);
            margin-bottom: 8px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        /* Divider */
        .divider {
            height: 1px;
            background: var(--border);
            margin: 20px 0;
            position: relative;
        }

        .divider-label {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: var(--bg-panel);
            padding: 0 10px;
            font-size: 0.8rem;
            color: var(--text-muted);
            font-style: italic;
        }

        /* Tooltips */
        .tooltip {
            position: relative;
        }

        .tooltip:hover::before {
            content: attr(data-tooltip);
            position: absolute;
            bottom: 100%;
            left: 50%;
            transform: translateX(-50%);
            background: var(--bg-app);
            color: var(--text-main);
            padding: 8px 12px;
            border-radius: var(--radius-sm);
            font-size: 0.8rem;
            white-space: nowrap;
            border: 1px solid var(--border);
            box-shadow: var(--shadow-lg);
            z-index: 1000;
            pointer-events: none;
        }

        /* ============================================
         * 5. FLOATING TOOLS & OVERLAYS
         * ============================================ */

        /* Tool Bar */
        .floating-bar {
            position: absolute;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(30, 30, 30, 0.95);
            backdrop-filter: blur(10px) saturate(180%);
            border: 1px solid var(--border);
            border-radius: var(--radius-lg);
            padding: 10px 20px;
            display: flex;
            gap: 8px;
            box-shadow: var(--shadow-xl);
            z-index: 100;
            transition: all var(--transition);
            border-top: 3px solid var(--accent);
        }

        .floating-bar:hover {
            transform: translateX(-50%) translateY(-2px);
            box-shadow: var(--shadow-xxl);
        }

        /* Mode Banner */
        .mode-banner {
            position: absolute;
            top: 30px;
            left: 50%;
            transform: translateX(-50%);
            background: var(--bg-panel);
            padding: 15px 25px;
            border-radius: var(--radius-lg);
            border: 2px solid var(--primary);
            display: none;
            align-items: center;
            gap: 20px;
            z-index: 200;
            box-shadow: var(--shadow-xl);
            animation: slideDown 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        }

        .mode-banner.active {
            display: flex;
        }

        @keyframes slideDown {
            from {
                transform: translate(-50%, -100%);
                opacity: 0;
            }
            to {
                transform: translate(-50%, 0);
                opacity: 1;
            }
        }

        /* Palette Grid */
        .palette-grid {
            display: grid;
            grid-template-columns: repeat(6, 1fr);
            gap: 6px;
            margin-top: 12px;
        }

        .swatch {
            height: 36px;
            border-radius: var(--radius-sm);
            cursor: pointer;
            border: 2px solid transparent;
            position: relative;
            transition: all var(--transition);
            overflow: hidden;
        }

        .swatch:hover {
            transform: scale(1.05);
            border-color: var(--primary);
            box-shadow: var(--shadow-md);
        }

        .swatch::after {
            content: 'ðŸ“‹';
            position: absolute;
            inset: 0;
            background: rgba(0,0,0,0.7);
            color: white;
            font-size: 0.8rem;
            display: flex;
            align-items: center;
            justify-content: center;
            opacity: 0;
            transition: opacity var(--transition);
        }

        .swatch:hover::after {
            opacity: 1;
        }

        .swatch.large {
            height: 60px;
            grid-column: span 2;
        }

        /* Toast Notification */
        .toast {
            position: fixed;
            bottom: 100px;
            left: 50%;
            transform: translateX(-50%);
            background: var(--bg-panel);
            color: var(--text-main);
            padding: 12px 24px;
            border-radius: var(--radius-lg);
            font-size: 0.9rem;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s, transform 0.3s;
            z-index: 1000;
            box-shadow: var(--shadow-xl);
            border: 1px solid var(--border);
            border-top: 3px solid var(--accent);
            max-width: 400px;
            text-align: center;
        }

        .toast.visible {
            opacity: 1;
            transform: translateX(-50%) translateY(-10px);
        }

        /* Drop Zone */
        .drop-overlay {
            position: fixed;
            inset: 0;
            background: rgba(0, 0, 0, 0.9);
            z-index: 2000;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s ease;
            color: white;
            backdrop-filter: blur(10px);
        }

        .drop-overlay.active {
            opacity: 1;
            pointer-events: all;
        }

        .drop-icon {
            font-size: 5rem;
            margin-bottom: 30px;
            animation: bounce 1.5s infinite;
        }

        @keyframes bounce {
            0%, 100% {
                transform: translateY(0);
            }
            50% {
                transform: translateY(-20px);
            }
        }

        .drop-text {
            text-align: center;
            max-width: 500px;
        }

        /* Loading Overlay */
        .loading-overlay {
            position: fixed;
            inset: 0;
            background: rgba(0, 0, 0, 0.8);
            z-index: 3000;
            display: none;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            color: white;
        }

        .loading-overlay.active {
            display: flex;
        }

        .spinner {
            width: 50px;
            height: 50px;
            border: 4px solid transparent;
            border-top-color: var(--accent);
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-bottom: 20px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        /* ============================================
         * 6. MODALS & DIALOGS
         * ============================================ */

        .modal-wrap {
            position: fixed;
            inset: 0;
            background: rgba(0,0,0,0.85);
            z-index: 4000;
            display: none;
            align-items: center;
            justify-content: center;
            backdrop-filter: blur(8px);
            animation: fadeIn 0.3s ease;
        }

        .modal-wrap.open {
            display: flex;
        }

        .modal-box {
            background: var(--bg-panel);
            width: 600px;
            max-width: 90vw;
            max-height: 85vh;
            border-radius: var(--radius-lg);
            border: 2px solid var(--border);
            overflow: hidden;
            box-shadow: var(--shadow-xxl);
            display: flex;
            flex-direction: column;
        }

        .modal-header {
            padding: 20px 25px;
            background: var(--bg-header);
            border-bottom: 1px solid var(--border);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .modal-title {
            font-size: 1.3rem;
            color: var(--primary);
            margin: 0;
            font-weight: 700;
        }

        .modal-close {
            background: none;
            border: none;
            color: var(--text-muted);
            font-size: 1.5rem;
            cursor: pointer;
            padding: 5px;
            border-radius: var(--radius-round);
            width: 36px;
            height: 36px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all var(--transition);
        }

        .modal-close:hover {
            background: var(--bg-input);
            color: var(--text-main);
        }

        .modal-body {
            padding: 25px;
            overflow-y: auto;
            flex: 1;
        }

        .modal-footer {
            padding: 20px 25px;
            background: var(--bg-header);
            border-top: 1px solid var(--border);
            display: flex;
            justify-content: flex-end;
            gap: 12px;
        }

        /* Shortcuts Modal */
        .shortcuts-grid {
            display: grid;
            grid-template-columns: 1fr auto;
            gap: 12px;
            align-items: center;
        }

        .key-row {
            display: contents;
        }

        .key-desc {
            padding: 10px 0;
            border-bottom: 1px solid var(--border);
            font-size: 0.9rem;
            color: var(--text-main);
        }

        .key-badge {
            background: var(--bg-input);
            padding: 6px 12px;
            border-radius: var(--radius-sm);
            font-family: var(--font-mono);
            font-size: 0.85rem;
            border: 1px solid var(--border);
            color: var(--text-main);
            white-space: nowrap;
            text-align: center;
            border-bottom: 1px solid var(--border);
        }

        .key-combo {
            display: flex;
            gap: 4px;
        }

        /* Theme Selector Modal */
        .theme-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 15px;
            margin-top: 20px;
        }

        .theme-card {
            padding: 20px;
            border-radius: var(--radius-md);
            border: 2px solid var(--border);
            cursor: pointer;
            transition: all var(--transition);
            text-align: center;
            position: relative;
            overflow: hidden;
        }

        .theme-card:hover {
            transform: translateY(-2px);
            box-shadow: var(--shadow-md);
            border-color: var(--accent);
        }

        .theme-card.active {
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(255,255,255,0.1);
        }

        .theme-card.active::after {
            content: 'âœ“';
            position: absolute;
            top: 10px;
            right: 10px;
            background: var(--primary);
            color: var(--bg-app);
            width: 24px;
            height: 24px;
            border-radius: var(--radius-round);
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
        }

        .theme-preview {
            width: 100%;
            height: 60px;
            border-radius: var(--radius-sm);
            margin-bottom: 10px;
            display: flex;
            overflow: hidden;
            border: 1px solid var(--border);
        }

        .theme-color {
            flex: 1;
        }

        /* Export Modal */
        .export-options {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 15px;
            margin: 20px 0;
        }

        .export-option {
            padding: 20px;
            border: 2px solid var(--border);
            border-radius: var(--radius-md);
            text-align: center;
            cursor: pointer;
            transition: all var(--transition);
        }

        .export-option:hover {
            border-color: var(--accent);
            background: var(--bg-input);
        }

        .export-icon {
            font-size: 2rem;
            margin-bottom: 10px;
            display: block;
        }

        /* ============================================
         * 7. SPECIFIC COMPONENTS
         * ============================================ */

        /* Color Picker Advanced */
        .color-picker-advanced {
            display: flex;
            gap: 15px;
            align-items: center;
        }

        .color-preview {
            width: 50px;
            height: 50px;
            border-radius: var(--radius-sm);
            border: 2px solid var(--border);
            cursor: pointer;
            transition: transform var(--transition);
        }

        .color-preview:hover {
            transform: scale(1.05);
        }

        .color-inputs {
            flex: 1;
        }

        .color-sliders {
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .color-slider {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .color-slider label {
            width: 60px;
            font-size: 0.8rem;
            color: var(--text-muted);
        }

        /* Grid Preview */
        .grid-preview {
            width: 100%;
            height: 100px;
            background: var(--bg-input);
            border: 1px solid var(--border);
            border-radius: var(--radius-sm);
            overflow: hidden;
            position: relative;
            margin: 10px 0;
        }

        /* Shape Library */
        .shape-library {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 10px;
            margin-top: 10px;
        }

        .shape-item {
            padding: 15px;
            border: 2px solid var(--border);
            border-radius: var(--radius-sm);
            cursor: pointer;
            text-align: center;
            transition: all var(--transition);
            font-size: 1.5rem;
        }

        .shape-item:hover {
            border-color: var(--accent);
            background: var(--bg-active);
        }

        /* Brush Presets */
        .brush-presets {
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
            margin-top: 10px;
        }

        .brush-preset {
            width: 40px;
            height: 40px;
            border: 2px solid var(--border);
            border-radius: var(--radius-round);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all var(--transition);
        }

        .brush-preset:hover {
            border-color: var(--accent);
            transform: scale(1.1);
        }

        .brush-preset.active {
            border-color: var(--primary);
            background: var(--bg-active);
        }

        /* Layer List */
        .layer-list {
            max-height: 300px;
            overflow-y: auto;
            margin-top: 10px;
        }

        .layer-item {
            padding: 12px;
            border: 1px solid var(--border);
            border-radius: var(--radius-sm);
            margin-bottom: 8px;
            display: flex;
            align-items: center;
            gap: 12px;
            cursor: move;
            transition: all var(--transition);
        }

        .layer-item:hover {
            border-color: var(--accent);
            background: var(--bg-active);
        }

        .layer-color {
            width: 20px;
            height: 20px;
            border-radius: var(--radius-round);
            border: 2px solid var(--border);
        }

        .layer-name {
            flex: 1;
            font-size: 0.9rem;
        }

        .layer-controls {
            display: flex;
            gap: 5px;
        }

        /* ============================================
         * 8. UTILITY CLASSES
         * ============================================ */
        .hidden { display: none !important; }
        .visible { display: block !important; }
        .flex { display: flex; }
        .flex-col { flex-direction: column; }
        .items-center { align-items: center; }
        .justify-center { justify-content: center; }
        .justify-between { justify-content: space-between; }
        .gap-1 { gap: 4px; }
        .gap-2 { gap: 8px; }
        .gap-3 { gap: 12px; }
        .gap-4 { gap: 16px; }
        .gap-5 { gap: 20px; }
        .w-full { width: 100%; }
        .h-full { height: 100%; }
        .text-center { text-align: center; }
        .text-left { text-align: left; }
        .text-right { text-align: right; }
        .text-sm { font-size: 0.85rem; }
        .text-xs { font-size: 0.75rem; }
        .text-lg { font-size: 1.1rem; }
        .text-xl { font-size: 1.3rem; }
        .font-bold { font-weight: 700; }
        .font-semibold { font-weight: 600; }
        .font-mono { font-family: var(--font-mono); }
        .mt-1 { margin-top: 4px; }
        .mt-2 { margin-top: 8px; }
        .mt-3 { margin-top: 12px; }
        .mt-4 { margin-top: 16px; }
        .mt-5 { margin-top: 20px; }
        .mb-1 { margin-bottom: 4px; }
        .mb-2 { margin-bottom: 8px; }
        .mb-3 { margin-bottom: 12px; }
        .mb-4 { margin-bottom: 16px; }
        .mb-5 { margin-bottom: 20px; }
        .ml-auto { margin-left: auto; }
        .mr-auto { margin-right: auto; }
        .pointer { cursor: pointer; }
        .select-none { user-select: none; }
        .truncate {
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }
        .opacity-50 { opacity: 0.5; }
        .opacity-75 { opacity: 0.75; }
        .shadow-sm { box-shadow: var(--shadow-sm); }
        .shadow-md { box-shadow: var(--shadow-md); }
        .shadow-lg { box-shadow: var(--shadow-lg); }
        .rounded-sm { border-radius: var(--radius-sm); }
        .rounded-md { border-radius: var(--radius-md); }
        .rounded-lg { border-radius: var(--radius-lg); }
        .rounded-full { border-radius: var(--radius-round); }

        /* ============================================
         * 9. RESPONSIVE DESIGN
         * ============================================ */
        @media (max-width: 1200px) {
            .sidebar {
                width: 340px;
            }
            
            .theme-grid {
                grid-template-columns: repeat(2, 1fr);
            }
        }

        @media (max-width: 768px) {
            .app-header {
                padding: 0 15px;
                flex-wrap: wrap;
                height: auto;
                min-height: var(--header-height);
                padding-top: 10px;
                padding-bottom: 10px;
            }
            
            .branding {
                width: 100%;
                margin-bottom: 10px;
                text-align: center;
            }
            
            .header-controls {
                width: 100%;
                justify-content: center;
            }
            
            .sidebar {
                position: fixed;
                top: 0;
                left: 0;
                height: 100vh;
                z-index: 2000;
                transform: translateX(-100%);
                margin-right: 0;
            }
            
            .sidebar.active {
                transform: translateX(0);
            }
            
            .floating-bar {
                flex-wrap: wrap;
                justify-content: center;
                width: 90%;
                padding: 10px;
            }
            
            .mode-banner {
                flex-wrap: wrap;
                width: 90%;
                text-align: center;
            }
            
            .theme-grid {
                grid-template-columns: 1fr;
            }
            
            .export-options {
                grid-template-columns: 1fr;
            }
        }

        @media (max-width: 480px) {
            .tab-btn {
                padding: 12px 0;
                font-size: 0.75rem;
            }
            
            .floating-bar {
                bottom: 10px;
                width: 95%;
            }
            
            .modal-box {
                width: 95vw;
                max-height: 90vh;
            }
        }

        /* ============================================
         * 10. ANIMATIONS
         * ============================================ */
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        @keyframes slideInRight {
            from {
                transform: translateX(100%);
                opacity: 0;
            }
            to {
                transform: translateX(0);
                opacity: 1;
            }
        }

        @keyframes slideInLeft {
            from {
                transform: translateX(-100%);
                opacity: 0;
            }
            to {
                transform: translateX(0);
                opacity: 1;
            }
        }

        @keyframes fadeInUp {
            from {
                transform: translateY(20px);
                opacity: 0;
            }
            to {
                transform: translateY(0);
                opacity: 1;
            }
        }

        @keyframes shake {
            0%, 100% { transform: translateX(0); }
            25% { transform: translateX(-5px); }
            75% { transform: translateX(5px); }
        }

        .animate-pulse {
            animation: pulse 2s infinite;
        }

        .animate-slide-in-right {
            animation: slideInRight 0.3s ease;
        }

        .animate-slide-in-left {
            animation: slideInLeft 0.3s ease;
        }

        .animate-fade-in-up {
            animation: fadeInUp 0.3s ease;
        }

        .animate-shake {
            animation: shake 0.5s ease;
        }

        /* ============================================
         * 11. PRINT STYLES
         * ============================================ */
        @media print {
            .app-header,
            .sidebar,
            .floating-bar,
            .mode-banner,
            .drop-overlay,
            .modal-wrap,
            .toast {
                display: none !important;
            }
            
            .viewport {
                background: white !important;
            }
            
            canvas {
                box-shadow: none !important;
                max-width: 100% !important;
                max-height: 100% !important;
            }
        }

    </style>
</head>
<body>
    <!-- Drop Zone Overlay -->
    <div id="dropZone" class="drop-overlay">
        <div class="drop-icon">ðŸ“‚</div>
        <div class="drop-text">
            <h1>Drop Your Image Here</h1>
            <p>Supports PNG, JPG, WEBP, GIF, SVG, BMP</p>
            <p class="text-sm opacity-75 mt-3">You can also paste an image from clipboard (Ctrl+V)</p>
        </div>
    </div>

    <!-- Loading Overlay -->
    <div id="loadingOverlay" class="loading-overlay">
        <div class="spinner"></div>
        <p id="loadingText">Processing...</p>
    </div>

    <!-- Toast Notification -->
    <div id="toast" class="toast"></div>

    <!-- Modal: Keyboard Shortcuts -->
    <div id="modalShortcuts" class="modal-wrap">
        <div class="modal-box">
            <div class="modal-header">
                <h2 class="modal-title">Keyboard Shortcuts</h2>
                <button class="modal-close" onclick="App.ui.closeModal('shortcuts')">Ã—</button>
            </div>
            <div class="modal-body">
                <div class="shortcuts-grid">
                    <div class="key-desc">Toggle Grid Visibility</div>
                    <div class="key-badge">H</div>
                    
                    <div class="key-desc">Undo Last Action</div>
                    <div class="key-combo">
                        <span class="key-badge">Ctrl</span>
                        <span class="key-badge">Z</span>
                    </div>
                    
                    <div class="key-desc">Redo Last Action</div>
                    <div class="key-combo">
                        <span class="key-badge">Ctrl</span>
                        <span class="key-badge">Y</span>
                    </div>
                    
                    <div class="key-desc">Toggle Focus Mode (Hide UI)</div>
                    <div class="key-badge">F</div>
                    
                    <div class="key-desc">Pan Tool</div>
                    <div class="key-badge">P</div>
                    
                    <div class="key-desc">Crop Tool</div>
                    <div class="key-badge">C</div>
                    
                    <div class="key-desc">Draw Tool</div>
                    <div class="key-badge">D</div>
                    
                    <div class="key-desc">Measure Tool</div>
                    <div class="key-badge">M</div>
                    
                    <div class="key-desc">Text Tool</div>
                    <div class="key-badge">T</div>
                    
                    <div class="key-desc">Shape Tool</div>
                    <div class="key-badge">S</div>
                    
                    <div class="key-desc">Lock/Unlock View</div>
                    <div class="key-badge">L</div>
                    
                    <div class="key-desc">Reset View</div>
                    <div class="key-badge">R</div>
                    
                    <div class="key-desc">Save/Download Image</div>
                    <div class="key-badge">Ctrl+S</div>
                    
                    <div class="key-desc">Copy Image to Clipboard</div>
                    <div class="key-combo">
                        <span class="key-badge">Ctrl</span>
                        <span class="key-badge">Shift</span>
                        <span class="key-badge">C</span>
                    </div>
                    
                    <div class="key-desc">Open Image</div>
                    <div class="key-combo">
                        <span class="key-badge">Ctrl</span>
                        <span class="key-badge">O</span>
                    </div>
                    
                    <div class="key-desc">Clear Everything</div>
                    <div class="key-combo">
                        <span class="key-badge">Ctrl</span>
                        <span class="key-badge">Shift</span>
                        <span class="key-badge">Del</span>
                    </div>
                    
                    <div class="key-desc">Toggle Theme</div>
                    <div class="key-badge">Ctrl+T</div>
                    
                    <div class="key-desc">Zoom In</div>
                    <div class="key-combo">
                        <span class="key-badge">Ctrl</span>
                        <span class="key-badge">+</span>
                    </div>
                    
                    <div class="key-desc">Zoom Out</div>
                    <div class="key-combo">
                        <span class="key-badge">Ctrl</span>
                        <span class="key-badge">-</span>
                    </div>
                    
                    <div class="key-desc">Reset Zoom</div>
                    <div class="key-badge">0</div>
                    
                    <div class="key-desc">Move Grid Up</div>
                    <div class="key-badge">â†‘</div>
                    
                    <div class="key-desc">Move Grid Down</div>
                    <div class="key-badge">â†“</div>
                    
                    <div class="key-desc">Move Grid Left</div>
                    <div class="key-badge">â†</div>
                    
                    <div class="key-desc">Move Grid Right</div>
                    <div class="key-badge">â†’</div>
                </div>
            </div>
            <div class="modal-footer">
                <button class="btn btn-primary" onclick="App.ui.closeModal('shortcuts')">Close</button>
            </div>
        </div>
    </div>

    <!-- Modal: Theme Selector -->
    <div id="modalTheme" class="modal-wrap">
        <div class="modal-box">
            <div class="modal-header">
                <h2 class="modal-title">Select Theme</h2>
                <button class="modal-close" onclick="App.ui.closeModal('theme')">Ã—</button>
            </div>
            <div class="modal-body">
                <p>Choose a theme for the application interface:</p>
                <div class="theme-grid" id="themeGrid">
                    <!-- Themes will be populated by JavaScript -->
                </div>
                <div class="divider mt-4 mb-4"></div>
                <h3 class="font-semibold mb-3">Custom Theme</h3>
                <div class="row">
                    <div class="col">
                        <label>Primary Color</label>
                        <input type="color" id="customPrimary" value="#ffffff">
                    </div>
                    <div class="col">
                        <label>Background Color</label>
                        <input type="color" id="customBg" value="#121212">
                    </div>
                    <div class="col">
                        <label>Accent Color</label>
                        <input type="color" id="customAccent" value="#4fc3f7">
                    </div>
                </div>
                <div class="row mt-3">
                    <button class="btn btn-primary" onclick="App.ui.applyCustomTheme()">Apply Custom Theme</button>
                    <button class="btn" onclick="App.ui.resetCustomTheme()">Reset</button>
                </div>
            </div>
            <div class="modal-footer">
                <button class="btn btn-primary" onclick="App.ui.closeModal('theme')">Done</button>
            </div>
        </div>
    </div>

    <!-- Modal: Export Options -->
    <div id="modalExport" class="modal-wrap">
        <div class="modal-box">
            <div class="modal-header">
                <h2 class="modal-title">Export Image</h2>
                <button class="modal-close" onclick="App.ui.closeModal('export')">Ã—</button>
            </div>
            <div class="modal-body">
                <div class="export-options">
                    <div class="export-option" onclick="App.export.download('png')">
                        <span class="export-icon">ðŸ–¼ï¸</span>
                        <div class="font-semibold">PNG</div>
                        <div class="text-xs opacity-75">Lossless, transparent</div>
                    </div>
                    <div class="export-option" onclick="App.export.download('jpg')">
                        <span class="export-icon">ðŸ“¸</span>
                        <div class="font-semibold">JPEG</div>
                        <div class="text-xs opacity-75">Compressed, smaller</div>
                    </div>
                    <div class="export-option" onclick="App.export.download('webp')">
                        <span class="export-icon">ðŸŒ</span>
                        <div class="font-semibold">WebP</div>
                        <div class="text-xs opacity-75">Modern, efficient</div>
                    </div>
                    <div class="export-option" onclick="App.export.copyToClipboard()">
                        <span class="export-icon">ðŸ“‹</span>
                        <div class="font-semibold">Clipboard</div>
                        <div class="text-xs opacity-75">Copy to clipboard</div>
                    </div>
                    <div class="export-option" onclick="App.export.print()">
                        <span class="export-icon">ðŸ–¨ï¸</span>
                        <div class="font-semibold">Print</div>
                        <div class="text-xs opacity-75">Print directly</div>
                    </div>
                    <div class="export-option" onclick="App.export.openInNewTab()">
                        <span class="export-icon">ðŸ”—</span>
                        <div class="font-semibold">New Tab</div>
                        <div class="text-xs opacity-75">Open in new tab</div>
                    </div>
                </div>
                
                <div class="divider mt-4 mb-4"></div>
                
                <h3 class="font-semibold mb-3">Export Settings</h3>
                <div class="row">
                    <div class="col">
                        <label>Quality (JPEG/WebP)</label>
                        <input type="range" id="exportQuality" min="1" max="100" value="90">
                        <div class="text-right text-xs" id="qualityValue">90%</div>
                    </div>
                    <div class="col">
                        <label>Scale Factor</label>
                        <select id="exportScale">
                            <option value="1">100% (Original)</option>
                            <option value="2">200% (2x)</option>
                            <option value="0.5">50% (0.5x)</option>
                            <option value="0.25">25% (0.25x)</option>
                        </select>
                    </div>
                </div>
                
                <div class="row mt-3">
                    <div class="col">
                        <label class="chk-label">
                            <input type="checkbox" id="exportWithGrid" checked> Include Grid
                        </label>
                    </div>
                    <div class="col">
                        <label class="chk-label">
                            <input type="checkbox" id="exportWithAnnotations" checked> Include Annotations
                        </label>
                    </div>
                </div>
            </div>
            <div class="modal-footer">
                <button class="btn btn-primary" onclick="App.export.download('png')">Export Now</button>
                <button class="btn" onclick="App.ui.closeModal('export')">Cancel</button>
            </div>
        </div>
    </div>

    <!-- Modal: About -->
    <div id="modalAbout" class="modal-wrap">
        <div class="modal-box">
            <div class="modal-header">
                <h2 class="modal-title">About Grid Generator</h2>
                <button class="modal-close" onclick="App.ui.closeModal('about')">Ã—</button>
            </div>
            <div class="modal-body">
                <div class="text-center mb-4">
                    <h1 class="text-xl font-bold mb-2">That Time I Generated a Grid on My Image</h1>
                    <p class="text-sm opacity-75">Version 3.0.0 â€¢ Ultimate Professional Edition</p>
                </div>
                
                <div class="card mb-3">
                    <div class="card-title">
                        <span>ðŸš€ Features</span>
                    </div>
                    <ul style="padding-left: 20px; margin: 0;">
                        <li>Multiple grid types (Rectangular, Isometric, Polar, Hexagonal)</li>
                        <li>Advanced sub-grid systems</li>
                        <li>Professional drawing tools with layers</li>
                        <li>Image editing and filters</li>
                        <li>Measurement and analysis tools</li>
                        <li>Multiple themes and customization</li>
                        <li>Export to various formats</li>
                        <li>Keyboard shortcuts for efficiency</li>
                    </ul>
                </div>
                
                <div class="card mb-3">
                    <div class="card-title">
                        <span>âš™ï¸ Technology</span>
                    </div>
                    <p>Built with pure HTML5 Canvas API. Runs entirely in your browser â€” no data sent to servers.</p>
                </div>
                
                <div class="card">
                    <div class="card-title">
                        <span>ðŸ‘¨â€ðŸ’» Developer</span>
                    </div>
                    <p>Developed with â¤ï¸ by <strong>Yigit Guven</strong></p>
                    <p class="text-sm mt-2">A passionate developer creating tools that make design and development easier.</p>
                </div>
            </div>
            <div class="modal-footer">
                <button class="btn btn-primary" onclick="App.ui.closeModal('about')">Close</button>
            </div>
        </div>
    </div>

    <!-- Crop Mode Banner -->
    <div id="bannerCrop" class="mode-banner">
        <span style="font-weight:bold; color:var(--accent);">âœ‚ï¸ CROP MODE</span>
        <span>Drag a box on the image to select crop area.</span>
        <button class="btn btn-primary btn-sm" onclick="App.crop.apply()">Apply Crop</button>
        <button class="btn btn-sm" onclick="App.crop.cancel()">Cancel</button>
    </div>
    
    <!-- Measure Mode Banner -->
    <div id="bannerMeasure" class="mode-banner">
        <span style="font-weight:bold; color:var(--success);">ðŸ“ MEASUREMENT MODE</span>
        <span id="measureOutput">Click and drag to measure distance. Press Esc to exit.</span>
        <button class="btn btn-sm" onclick="App.tools.setMode('pan')">Done</button>
    </div>
    
    <!-- Text Mode Banner -->
    <div id="bannerText" class="mode-banner">
        <span style="font-weight:bold; color:var(--info);">âœï¸ TEXT MODE</span>
        <span>Click on image to add text. Double-click to edit.</span>
        <div class="row gap-2">
            <select id="textFont" style="width: 120px;" onchange="App.text.updateCurrentFont(this.value)">
                <option value="Arial">Arial</option>
                <option value="Helvetica">Helvetica</option>
                <option value="Times New Roman">Times New Roman</option>
                <option value="Courier New">Courier New</option>
                <option value="Georgia">Georgia</option>
                <option value="Verdana">Verdana</option>
            </select>
            <input type="number" id="textSize" value="24" min="8" max="72" style="width: 60px;" onchange="App.text.updateCurrentSize(this.value)">
            <input type="color" id="textColor" value="#ffffff" style="width: 40px;" onchange="App.text.updateCurrentColor(this.value)">
            <button class="btn btn-sm btn-danger" onclick="App.tools.setMode('pan')">âœ• Cancel</button>
        </div>
    </div>

    <!-- Main App Container -->
    <div class="app-container">
        
        <header class="app-header">
            <div class="branding">
                <h1>That Time I Generated a Grid on My Image</h1>
                <small>A professional, client-side tool for grid overlays, annotations, and image analysis</small>
                <span class="branding-subtitle">Ultimate Professional Edition â€¢ No data leaves your browser</span>
            </div>
            <div class="header-controls">
                <input type="file" id="fileInput" hidden accept="image/*">
                <button class="btn btn-primary" onclick="document.getElementById('fileInput').click()" title="Open Image (Ctrl+O)">
                    <span>ðŸ“‚</span> Open
                </button>
                <button class="btn" onclick="App.history.undo()" title="Undo (Ctrl+Z)">â†©ï¸ Undo</button>
                <button class="btn" onclick="App.history.redo()" title="Redo (Ctrl+Y)">â†ªï¸ Redo</button>
                <button class="btn" onclick="App.ui.showModal('shortcuts')" title="Keyboard Shortcuts">âŒ¨ï¸ Shortcuts</button>
                <button class="btn" onclick="App.ui.showModal('theme')" title="Change Theme">ðŸŽ¨ Theme</button>
                <button class="btn btn-danger" onclick="App.clearAll()" title="Clear Everything (Ctrl+Shift+Del)">ðŸ—‘ï¸ Clear All</button>
            </div>
        </header>

        <div class="app-body">
            
            <!-- Sidebar -->
            <aside class="sidebar" id="sidebar">
                
                <div class="sidebar-tabs">
                    <button class="tab-btn active" onclick="App.ui.switchTab('grid')" data-tooltip="Grid Configuration">
                        ðŸ“ GRID
                    </button>
                    <button class="tab-btn" onclick="App.ui.switchTab('sub')" data-tooltip="Sub-Grid & Advanced">
                        ðŸ”¬ ADVANCED
                    </button>
                    <button class="tab-btn" onclick="App.ui.switchTab('draw')" data-tooltip="Drawing & Annotations">
                        âœï¸ DRAW
                    </button>
                    <button class="tab-btn" onclick="App.ui.switchTab('tools')" data-tooltip="Tools & Utilities">
                        ðŸ› ï¸ TOOLS
                    </button>
                    <button class="tab-btn" onclick="App.ui.switchTab('edit')" data-tooltip="Image Editing">
                        ðŸŽ¨ EDIT
                    </button>
                    <button class="tab-btn" onclick="App.ui.switchTab('export')" data-tooltip="Export & Share">
                        ðŸ“¤ EXPORT
                    </button>
                </div>

                <div class="sidebar-scroll">
                    
                    <!-- Tab 1: Grid Configuration -->
                    <div id="tab-grid" class="tab-content active">
                        <div class="control-group">
                            <div class="control-group-title">
                                <span>Grid Type</span>
                                <span class="icon">ðŸ”²</span>
                            </div>
                            <div class="radio-group">
                                <label class="radio-label active" onclick="App.state.set('gridType', 'standard')">
                                    <input type="radio" name="gridType" checked> Rectangular
                                </label>
                                <label class="radio-label" onclick="App.state.set('gridType', 'isometric')">
                                    <input type="radio" name="gridType"> Isometric
                                </label>
                                <label class="radio-label" onclick="App.state.set('gridType', 'radial')">
                                    <input type="radio" name="gridType"> Polar
                                </label>
                                <label class="radio-label" onclick="App.state.set('gridType', 'hexagonal')">
                                    <input type="radio" name="gridType"> Hexagonal
                                </label>
                            </div>
                        </div>

                        <div class="control-group">
                            <div class="control-group-title">
                                <span>Grid Configuration</span>
                                <div class="row" style="width:auto">
                                    <button class="btn btn-sm active" id="modeCount" onclick="App.state.set('gridMode', 'count')">By Count</button>
                                    <button class="btn btn-sm" id="modeSize" onclick="App.state.set('gridMode', 'size')">By Size</button>
                                    <button class="btn btn-sm" id="modeAuto" onclick="App.state.set('gridMode', 'auto')">Auto</button>
                                </div>
                            </div>
                            
                            <div id="inputGroupCount">
                                <div class="row">
                                    <div class="col">
                                        <label>Rows</label>
                                        <input type="number" id="gridRows" value="8" min="1" max="1000" oninput="App.state.set('gridRows', this.value)">
                                    </div>
                                    <div class="col">
                                        <label>Columns</label>
                                        <input type="number" id="gridCols" value="8" min="1" max="1000" oninput="App.state.set('gridCols', this.value)">
                                    </div>
                                    <div class="col">
                                        <label>Aspect Ratio</label>
                                        <select id="gridAspect" onchange="App.state.set('gridAspect', this.value)">
                                            <option value="1:1">1:1</option>
                                            <option value="16:9">16:9</option>
                                            <option value="4:3">4:3</option>
                                            <option value="custom">Custom</option>
                                        </select>
                                    </div>
                                </div>
                            </div>

                            <div id="inputGroupSize" class="hidden">
                                <div class="row">
                                    <div class="col">
                                        <label>Cell Width (px)</label>
                                        <input type="number" id="gridWidth" value="100" min="5" max="1000" oninput="App.state.set('gridWidth', this.value)">
                                    </div>
                                    <div class="col">
                                        <label>Cell Height (px)</label>
                                        <input type="number" id="gridHeight" value="100" min="5" max="1000" oninput="App.state.set('gridHeight', this.value)">
                                    </div>
                                </div>
                            </div>

                            <div id="inputGroupAuto" class="hidden">
                                <label>Grid Density</label>
                                <input type="range" id="gridDensity" min="1" max="10" value="5" oninput="App.state.set('gridDensity', this.value)">
                                <div class="text-right text-xs">Adjusts automatically based on image size</div>
                            </div>
                        </div>

                        <div class="control-group">
                            <div class="control-group-title">
                                <span>Grid Style</span>
                                <span class="icon">ðŸŽ¨</span>
                            </div>
                            <div class="row">
                                <div class="col" style="flex:0 0 60px">
                                    <label>Color</label>
                                    <input type="color" id="gridColor" value="#ffffff" oninput="App.state.set('gridColor', this.value)">
                                </div>
                                <div class="col">
                                    <label>Thickness</label>
                                    <input type="range" id="gridThick" value="2" min="0.5" max="10" step="0.5" oninput="App.state.set('gridThick', this.value)">
                                    <div class="text-right text-xs" id="thickValue">2px</div>
                                </div>
                                <div class="col">
                                    <label>Style</label>
                                    <select id="gridLineStyle" onchange="App.state.set('gridLineStyle', this.value)">
                                        <option value="solid">Solid</option>
                                        <option value="dashed">Dashed</option>
                                        <option value="dotted">Dotted</option>
                                        <option value="double">Double</option>
                                        <option value="dash-dot">Dash-Dot</option>
                                    </select>
                                </div>
                            </div>
                            <div class="row mt-2">
                                <div class="col">
                                    <label>Opacity</label>
                                    <input type="range" id="gridOpacity" min="0" max="1" step="0.05" value="1" oninput="App.state.set('gridOpacity', this.value)">
                                    <div class="text-right text-xs" id="opacityValue">100%</div>
                                </div>
                                <div class="col">
                                    <label>Blend Mode</label>
                                    <select id="gridBlend" onchange="App.state.set('gridBlend', this.value)">
                                        <option value="source-over">Normal</option>
                                        <option value="multiply">Multiply</option>
                                        <option value="screen">Screen</option>
                                        <option value="overlay">Overlay</option>
                                        <option value="difference">Difference</option>
                                        <option value="exclusion">Exclusion</option>
                                    </select>
                                </div>
                            </div>
                        </div>

                        <div class="control-group">
                            <div class="control-group-title">
                                <span>Grid Position & Offset</span>
                                <span class="icon">ðŸ“</span>
                            </div>
                            <div class="row">
                                <div class="col">
                                    <label>Offset X</label>
                                    <input type="number" id="gridOffsetX" value="0" oninput="App.state.set('gridOffsetX', this.value)">
                                </div>
                                <div class="col">
                                    <label>Offset Y</label>
                                    <input type="number" id="gridOffsetY" value="0" oninput="App.state.set('gridOffsetY', this.value)">
                                </div>
                                <div class="col-auto">
                                    <label>&nbsp;</label>
                                    <button class="btn btn-sm" onclick="App.state.set('gridOffsetX', 0); App.state.set('gridOffsetY', 0)" title="Reset Offset">
                                        âŸ² Reset
                                    </button>
                                </div>
                            </div>
                            <div class="row mt-2">
                                <div class="col">
                                    <label>Rotation</label>
                                    <input type="range" id="gridRotation" min="0" max="360" value="0" oninput="App.state.set('gridRotation', this.value)">
                                    <div class="text-right text-xs" id="rotationValue">0Â°</div>
                                </div>
                                <div class="col-auto">
                                    <label>&nbsp;</label>
                                    <button class="btn btn-sm" onclick="App.state.set('gridRotation', 0)" title="Reset Rotation">
                                        0Â°
                                    </button>
                                </div>
                            </div>
                        </div>

                        <div class="control-group">
                            <div class="control-group-title">
                                <span>Labels & Coordinates</span>
                                <span class="icon">ðŸ”¤</span>
                            </div>
                            <div class="row">
                                <label class="chk-label">
                                    <input type="checkbox" id="showLabels" checked onchange="App.state.set('showLabels', this.checked)">
                                    Show Cell Labels (A1, B2, C3)
                                </label>
                            </div>
                            <div class="row">
                                <div class="col">
                                    <label>Label Font Size</label>
                                    <input type="range" id="labelSize" min="8" max="24" value="12" oninput="App.state.set('labelSize', this.value)">
                                </div>
                                <div class="col">
                                    <label>Label Color</label>
                                    <input type="color" id="labelColor" value="#ffffff" oninput="App.state.set('labelColor', this.value)">
                                </div>
                            </div>
                            <div class="row">
                                <label class="chk-label">
                                    <input type="checkbox" id="showCoordinates" checked onchange="App.state.set('showCoordinates', this.checked)">
                                    Show Coordinate System
                                </label>
                            </div>
                        </div>
                    </div>

                    <!-- Tab 2: Advanced Grid Features -->
                    <div id="tab-sub" class="tab-content">
                        <div class="control-group">
                            <div class="control-group-title">
                                <span>Sub-Grid System</span>
                                <span class="icon">ðŸ”¬</span>
                            </div>
                            <div class="row">
                                <label class="chk-label">
                                    <input type="checkbox" id="subGridEnabled" onchange="App.state.set('subGridEnabled', this.checked)">
                                    Enable Sub-Grid System
                                </label>
                            </div>
                            
                            <div id="subGridControls" class="hidden">
                                <div class="row mt-3">
                                    <div class="col">
                                        <label>Divisions per Cell</label>
                                        <input type="number" id="subGridDivs" value="4" min="2" max="20" oninput="App.state.set('subGridDivs', this.value)">
                                    </div>
                                    <div class="col">
                                        <label>Sub-Grid Type</label>
                                        <select id="subGridType" onchange="App.state.set('subGridType', this.value)">
                                            <option value="lines">Lines</option>
                                            <option value="dots">Dots</option>
                                            <option value="crosses">Crosses</option>
                                            <option value="alternating">Alternating</option>
                                            <option value="faded">Faded</option>
                                        </select>
                                    </div>
                                </div>
                                
                                <div class="row mt-3">
                                    <div class="col">
                                        <label>Sub-Grid Color</label>
                                        <input type="color" id="subGridColor" value="#888888" oninput="App.state.set('subGridColor', this.value)">
                                    </div>
                                    <div class="col">
                                        <label>Thickness</label>
                                        <input type="range" id="subGridThick" value="1" min="0.5" max="5" step="0.5" oninput="App.state.set('subGridThick', this.value)">
                                    </div>
                                </div>
                                
                                <div class="row mt-3">
                                    <div class="col">
                                        <label>Opacity</label>
                                        <input type="range" id="subGridOpacity" min="0" max="1" step="0.05" value="0.5" oninput="App.state.set('subGridOpacity', this.value)">
                                    </div>
                                    <div class="col">
                                        <label>Style</label>
                                        <select id="subGridLineStyle" onchange="App.state.set('subGridLineStyle', this.value)">
                                            <option value="solid">Solid</option>
                                            <option value="dashed">Dashed</option>
                                            <option value="dotted">Dotted</option>
                                        </select>
                                    </div>
                                </div>
                                
                                <div class="row mt-3">
                                    <label class="chk-label">
                                        <input type="checkbox" id="subGridNumbers" onchange="App.state.set('subGridNumbers', this.checked)">
                                        Show Sub-Grid Numbers
                                    </label>
                                </div>
                            </div>
                        </div>

                        <div class="control-group">
                            <div class="control-group-title">
                                <span>Grid Patterns & Textures</span>
                                <span class="icon">ðŸŒ€</span>
                            </div>
                            <div class="row">
                                <div class="col">
                                    <label>Pattern Overlay</label>
                                    <select id="gridPattern" onchange="App.state.set('gridPattern', this.value)">
                                        <option value="none">None</option>
                                        <option value="dots">Dots</option>
                                        <option value="stripes">Stripes</option>
                                        <option value="checkerboard">Checkerboard</option>
                                        <option value="diagonal">Diagonal</option>
                                        <option value="crosshatch">Crosshatch</option>
                                    </select>
                                </div>
                                <div class="col">
                                    <label>Pattern Scale</label>
                                    <input type="range" id="patternScale" min="0.1" max="2" step="0.1" value="1" oninput="App.state.set('patternScale', this.value)">
                                </div>
                            </div>
                            <div class="row mt-2">
                                <div class="col">
                                    <label>Pattern Color</label>
                                    <input type="color" id="patternColor" value="#ffffff" oninput="App.state.set('patternColor', this.value)">
                                </div>
                                <div class="col">
                                    <label>Pattern Opacity</label>
                                    <input type="range" id="patternOpacity" min="0" max="1" step="0.05" value="0.3" oninput="App.state.set('patternOpacity', this.value)">
                                </div>
                            </div>
                        </div>

                        <div class="control-group">
                            <div class="control-group-title">
                                <span>Grid Snap & Alignment</span>
                                <span class="icon">ðŸ§²</span>
                            </div>
                            <div class="row">
                                <label class="chk-label">
                                    <input type="checkbox" id="snapToGrid" onchange="App.state.set('snapToGrid', this.checked)">
                                    Enable Snap to Grid
                                </label>
                            </div>
                            <div class="row">
                                <div class="col">
                                    <label>Snap Strength</label>
                                    <input type="range" id="snapStrength" min="1" max="20" value="10" oninput="App.state.set('snapStrength', this.value)">
                                </div>
                                <div class="col">
                                    <label>Snap Radius</label>
                                    <input type="range" id="snapRadius" min="1" max="50" value="10" oninput="App.state.set('snapRadius', this.value)">
                                </div>
                            </div>
                            <div class="row">
                                <label class="chk-label">
                                    <input type="checkbox" id="showSnapPoints" onchange="App.state.set('showSnapPoints', this.checked)">
                                    Highlight Snap Points
                                </label>
                            </div>
                        </div>

                        <div class="control-group">
                            <div class="control-group-title">
                                <span>Grid Analysis</span>
                                <span class="icon">ðŸ“Š</span>
                            </div>
                            <div class="row">
                                <button class="btn btn-sm col" onclick="App.grid.analyzeContrast()">Analyze Contrast</button>
                                <button class="btn btn-sm col" onclick="App.grid.analyzeSymmetry()">Check Symmetry</button>
                            </div>
                            <div class="row mt-2">
                                <button class="btn btn-sm col" onclick="App.grid.calculateGoldenRatio()">Golden Ratio</button>
                                <button class="btn btn-sm col" onclick="App.grid.calculateRuleOfThirds()">Rule of Thirds</button>
                            </div>
                            <div class="row mt-3">
                                <label class="chk-label">
                                    <input type="checkbox" id="showGridStats" onchange="App.state.set('showGridStats', this.checked)">
                                    Show Grid Statistics
                                </label>
                            </div>
                        </div>
                    </div>

                    <!-- Tab 3: Drawing & Annotations -->
                    <div id="tab-draw" class="tab-content">
                        <div class="control-group">
                            <div class="control-group-title">
                                <span>Drawing Tools</span>
                                <span class="icon">âœï¸</span>
                            </div>
                            <div class="row" style="margin-bottom:12px">
                                <button class="btn btn-sm col active" id="btnDrawPen" onclick="App.tools.setDrawMode('pen')">âœï¸ Pen</button>
                                <button class="btn btn-sm col" id="btnDrawEraser" onclick="App.tools.setDrawMode('eraser')">ðŸ§¹ Eraser</button>
                                <button class="btn btn-sm col" id="btnDrawLine" onclick="App.tools.setDrawMode('line')">ðŸ“ Line</button>
                                <button class="btn btn-sm col" id="btnDrawArrow" onclick="App.tools.setDrawMode('arrow')">âž¡ï¸ Arrow</button>
                            </div>
                            <div class="row">
                                <button class="btn btn-sm col" id="btnDrawRect" onclick="App.tools.setDrawMode('rectangle')">â¬œ Rectangle</button>
                                <button class="btn btn-sm col" id="btnDrawCircle" onclick="App.tools.setDrawMode('circle')">â­• Circle</button>
                                <button class="btn btn-sm col" id="btnDrawText" onclick="App.tools.setDrawMode('text')">ðŸ”¤ Text</button>
                                <button class="btn btn-sm col btn-danger" onclick="App.draw.clear()">ðŸ—‘ï¸ Clear</button>
                            </div>
                        </div>

                        <div class="control-group">
                            <div class="control-group-title">
                                <span>Brush Properties</span>
                                <span class="icon">ðŸŽ¨</span>
                            </div>
                            <div class="row">
                                <div class="col" style="flex:0 0 50px">
                                    <label>Color</label>
                                    <input type="color" id="drawColor" value="#00e5ff" oninput="App.state.set('drawColor', this.value)">
                                </div>
                                <div class="col">
                                    <label>Size</label>
                                    <input type="range" id="drawSize" min="1" max="50" value="3" oninput="App.state.set('drawSize', this.value)">
                                    <div class="text-right text-xs" id="brushSizeValue">3px</div>
                                </div>
                                <div class="col">
                                    <label>Opacity</label>
                                    <input type="range" id="drawOpacity" min="0" max="1" step="0.1" value="1" oninput="App.state.set('drawOpacity', this.value)">
                                </div>
                            </div>
                            <div class="row mt-2">
                                <div class="col">
                                    <label>Brush Type</label>
                                    <select id="drawBrushType" onchange="App.state.set('drawBrushType', this.value)">
                                        <option value="round">Round</option>
                                        <option value="square">Square</option>
                                        <option value="calligraphy">Calligraphy</option>
                                        <option value="spray">Spray</option>
                                    </select>
                                </div>
                                <div class="col">
                                    <label>Pressure Sensitivity</label>
                                    <select id="drawPressure" onchange="App.state.set('drawPressure', this.value)">
                                        <option value="off">Off</option>
                                        <option value="size">Size</option>
                                        <option value="opacity">Opacity</option>
                                        <option value="both">Both</option>
                                    </select>
                                </div>
                            </div>
                        </div>

                        <div class="control-group">
                            <div class="control-group-title">
                                <span>Brush Presets</span>
                                <span class="icon">ðŸ’¾</span>
                            </div>
                            <div class="brush-presets" id="brushPresets">
                                <!-- Brush presets will be populated by JavaScript -->
                            </div>
                            <div class="row mt-3">
                                <button class="btn btn-sm col" onclick="App.draw.saveBrushPreset()">ðŸ’¾ Save Preset</button>
                                <button class="btn btn-sm col" onclick="App.draw.loadBrushPresets()">ðŸ”„ Load Presets</button>
                            </div>
                        </div>

                        <div class="control-group">
                            <div class="control-group-title">
                                <span>Layers</span>
                                <span class="icon">ðŸ“š</span>
                            </div>
                            <div class="layer-list" id="layerList">
                                <!-- Layers will be populated by JavaScript -->
                            </div>
                            <div class="row mt-3">
                                <button class="btn btn-sm col" onclick="App.layers.addLayer()">âž• Add Layer</button>
                                <button class="btn btn-sm col" onclick="App.layers.mergeLayers()">ðŸ”„ Merge Layers</button>
                            </div>
                        </div>

                        <div class="control-group">
                            <div class="control-group-title">
                                <span>Drawing Settings</span>
                                <span class="icon">âš™ï¸</span>
                            </div>
                            <div class="row">
                                <label class="chk-label">
                                    <input type="checkbox" id="drawSmooth" checked onchange="App.state.set('drawSmooth', this.checked)">
                                    Smooth Drawing
                                </label>
                            </div>
                            <div class="row">
                                <label class="chk-label">
                                    <input type="checkbox" id="drawFillShapes" checked onchange="App.state.set('drawFillShapes', this.checked)">
                                    Fill Shapes
                                </label>
                            </div>
                            <div class="row">
                                <div class="col">
                                    <label>Undo Steps</label>
                                    <input type="number" id="undoSteps" min="1" max="100" value="20" oninput="App.state.set('undoSteps', this.value)">
                                </div>
                                <div class="col">
                                    <label>Auto-Save Interval (s)</label>
                                    <input type="number" id="autoSave" min="0" max="60" value="10" oninput="App.state.set('autoSave', this.value)">
                                </div>
                            </div>
                        </div>
                    </div>

                    <!-- Tab 4: Tools & Utilities -->
                    <div id="tab-tools" class="tab-content">
                        
                        <div class="control-group">
                            <div class="control-group-title">
                                <span>Measurement Tools</span>
                                <span class="icon">ðŸ“</span>
                            </div>
                            <div class="row" style="flex-wrap:wrap">
                                <button class="btn btn-sm col" onclick="App.tools.setMode('measure')">ðŸ“ Distance</button>
                                <button class="btn btn-sm col" onclick="App.tools.measureAngle()">ðŸ“ Angle</button>
                                <button class="btn btn-sm col" onclick="App.tools.measureArea()">ðŸ“Š Area</button>
                                <button class="btn btn-sm col" onclick="App.tools.setMode('pan')">âœ‹ Pan</button>
                            </div>
                            <div class="row mt-3">
                                <label class="chk-label">
                                    <input type="checkbox" id="showMeasurements" checked onchange="App.state.set('showMeasurements', this.checked)">
                                    Always Show Measurements
                                </label>
                            </div>
                        </div>

                        <div class="control-group">
                            <div class="control-group-title">
                                <span>Reference Guides</span>
                                <span class="icon">ðŸŽ¯</span>
                            </div>
                            <div class="row" style="flex-wrap:wrap">
                                <button class="btn btn-sm col" id="tgCenter" onclick="App.state.toggle('guideCenter')">Center</button>
                                <button class="btn btn-sm col" id="tgThirds" onclick="App.state.toggle('guideThirds')">Thirds</button>
                                <button class="btn btn-sm col" id="tgGolden" onclick="App.state.toggle('guideGolden')">Golden</button>
                                <button class="btn btn-sm col" id="tgDiag" onclick="App.state.toggle('guideDiag')">Diagonal</button>
                            </div>
                            <div class="row mt-2">
                                <button class="btn btn-sm col" id="tgSpiral" onclick="App.state.toggle('guideSpiral')">Spiral</button>
                                <button class="btn btn-sm col" id="tgFibonacci" onclick="App.state.toggle('guideFibonacci')">Fibonacci</button>
                                <button class="btn btn-sm col" id="tgPerspective" onclick="App.state.toggle('guidePerspective')">Perspective</button>
                                <button class="btn btn-sm col" onclick="App.guides.clearAll()">Clear All</button>
                            </div>
                        </div>

                        <div class="control-group">
                            <div class="control-group-title">
                                <span>Color Analysis</span>
                                <span class="icon">ðŸŽ¨</span>
                            </div>
                            <button class="btn btn-block btn-sm" onclick="App.tools.generatePalette()">Generate Color Palette</button>
                            <div id="paletteBox" class="palette-grid mt-3"></div>
                            <div class="row mt-3">
                                <button class="btn btn-sm col" onclick="App.tools.analyzeColors()">Analyze Colors</button>
                                <button class="btn btn-sm col" onclick="App.tools.extractDominant()">Dominant Color</button>
                            </div>
                        </div>

                        <div class="control-group">
                            <div class="control-group-title">
                                <span>Image Information</span>
                                <span class="icon">â„¹ï¸</span>
                            </div>
                            <div id="imageInfo">
                                <div class="row">
                                    <span class="text-sm opacity-75">No image loaded</span>
                                </div>
                            </div>
                        </div>

                        <div class="control-group">
                            <div class="control-group-title">
                                <span>Batch Processing</span>
                                <span class="icon">âš¡</span>
                            </div>
                            <div class="row">
                                <button class="btn btn-sm col" onclick="App.batch.processGrid()">Apply Grid to Multiple</button>
                                <button class="btn btn-sm col" onclick="App.batch.exportAll()">Export All</button>
                            </div>
                        </div>
                    </div>

                    <!-- Tab 5: Image Editing -->
                    <div id="tab-edit" class="tab-content">
                        <div class="control-group">
                            <div class="control-group-title">
                                <span>Geometry Transformations</span>
                                <span class="icon">ðŸ”„</span>
                            </div>
                            <div class="row" style="margin-bottom:12px">
                                <button class="btn btn-primary btn-block" onclick="App.crop.start()">âœ‚ï¸ Crop Image (C)</button>
                            </div>
                            <div class="row">
                                <button class="btn btn-sm col" onclick="App.edit.rotate(90)">â†» 90Â°</button>
                                <button class="btn btn-sm col" onclick="App.edit.rotate(-90)">â†º 90Â°</button>
                                <button class="btn btn-sm col" onclick="App.edit.flip('h')">â†” Flip H</button>
                                <button class="btn btn-sm col" onclick="App.edit.flip('v')">â†• Flip V</button>
                            </div>
                            <div class="row mt-3">
                                <label>Free Rotation</label>
                                <input type="range" min="0" max="360" value="0" oninput="App.state.set('rotation', parseInt(this.value))">
                                <button class="btn btn-sm" onclick="App.state.set('rotation', 0)">0Â°</button>
                            </div>
                            <div class="row mt-3">
                                <div class="col">
                                    <label>Scale X (%)</label>
                                    <input type="range" id="scaleX" min="10" max="500" value="100" oninput="App.state.set('scaleX', this.value)">
                                </div>
                                <div class="col">
                                    <label>Scale Y (%)</label>
                                    <input type="range" id="scaleY" min="10" max="500" value="100" oninput="App.state.set('scaleY', this.value)">
                                </div>
                            </div>
                        </div>

                        <div class="control-group">
                            <div class="control-group-title">
                                <span>Color Adjustments</span>
                                <span class="icon">ðŸŒˆ</span>
                            </div>
                            
                            <label>Brightness</label>
                            <input type="range" min="0" max="200" value="100" oninput="App.state.set('filterBright', this.value)">
                            
                            <label>Contrast</label>
                            <input type="range" min="0" max="200" value="100" oninput="App.state.set('filterContrast', this.value)">
                            
                            <label>Saturation</label>
                            <input type="range" min="0" max="200" value="100" oninput="App.state.set('filterSat', this.value)">
                            
                            <label>Hue Rotation</label>
                            <input type="range" min="0" max="360" value="0" oninput="App.state.set('filterHue', this.value)">
                            
                            <label>Temperature</label>
                            <input type="range" min="-100" max="100" value="0" oninput="App.state.set('filterTemp', this.value)">
                            
                            <label>Tint</label>
                            <input type="range" min="-100" max="100" value="0" oninput="App.state.set('filterTint', this.value)">
                            
                            <div class="row mt-3">
                                <button class="btn btn-sm col" onclick="App.edit.toggleBW()">âš«âšª B&W</button>
                                <button class="btn btn-sm col" onclick="App.edit.toggleInvert()">ðŸ”„ Invert</button>
                                <button class="btn btn-sm col" onclick="App.edit.toggleSepia()">ðŸŸ¤ Sepia</button>
                                <button class="btn btn-sm col" onclick="App.edit.resetFilters()">âŸ² Reset</button>
                            </div>
                        </div>

                        <div class="control-group">
                            <div class="control-group-title">
                                <span>Effects & Filters</span>
                                <span class="icon">âœ¨</span>
                            </div>
                            
                            <label>Blur</label>
                            <input type="range" min="0" max="20" value="0" oninput="App.state.set('filterBlur', this.value)">
                            
                            <label>Sharpen</label>
                            <input type="range" min="0" max="10" value="0" oninput="App.state.set('filterSharpen', this.value)">
                            
                            <label>Noise</label>
                            <input type="range" min="0" max="50" value="0" oninput="App.state.set('filterNoise', this.value)">
                            
                            <label>Vignette</label>
                            <input type="range" min="0" max="100" value="0" oninput="App.state.set('filterVignette', this.value)">
                            
                            <div class="row mt-3">
                                <button class="btn btn-sm col" onclick="App.edit.applyVintage()">ðŸ“œ Vintage</button>
                                <button class="btn btn-sm col" onclick="App.edit.applyDramatic()">ðŸŽ­ Dramatic</button>
                                <button class="btn btn-sm col" onclick="App.edit.applyCool()">â„ï¸ Cool</button>
                                <button class="btn btn-sm col" onclick="App.edit.applyWarm()">ðŸ”¥ Warm</button>
                            </div>
                        </div>

                        <div class="control-group">
                            <div class="control-group-title">
                                <span>Advanced Adjustments</span>
                                <span class="icon">ðŸ”§</span>
                            </div>
                            
                            <label>Exposure</label>
                            <input type="range" min="-2" max="2" step="0.1" value="0" oninput="App.state.set('filterExposure', this.value)">
                            
                            <label>Gamma</label>
                            <input type="range" min="0.1" max="3" step="0.1" value="1" oninput="App.state.set('filterGamma', this.value)">
                            
                            <label>Highlights</label>
                            <input type="range" min="-100" max="100" value="0" oninput="App.state.set('filterHighlights', this.value)">
                            
                            <label>Shadows</label>
                            <input type="range" min="-100" max="100" value="0" oninput="App.state.set('filterShadows', this.value)">
                            
                            <div class="row mt-3">
                                <button class="btn btn-sm col" onclick="App.edit.autoLevels()">âš¡ Auto Levels</button>
                                <button class="btn btn-sm col" onclick="App.edit.autoContrast()">ðŸŽ¨ Auto Contrast</button>
                                <button class="btn btn-sm col" onclick="App.edit.autoColor()">ðŸŒˆ Auto Color</button>
                            </div>
                        </div>
                    </div>

                    <!-- Tab 6: Export & Share -->
                    <div id="tab-export" class="tab-content">
                        <div class="control-group">
                            <div class="control-group-title">
                                <span>Export Options</span>
                                <span class="icon">ðŸ“¤</span>
                            </div>
                            <button class="btn btn-primary btn-block mb-3" onclick="App.ui.showModal('export')">
                                ðŸš€ Open Export Dialog
                            </button>
                            <div class="row">
                                <button class="btn btn-sm col" onclick="App.export.download('png')">ðŸ–¼ï¸ PNG</button>
                                <button class="btn btn-sm col" onclick="App.export.download('jpg')">ðŸ“¸ JPEG</button>
                                <button class="btn btn-sm col" onclick="App.export.download('webp')">ðŸŒ WebP</button>
                            </div>
                            <div class="row mt-2">
                                <button class="btn btn-sm col" onclick="App.export.copyToClipboard()">ðŸ“‹ Clipboard</button>
                                <button class="btn btn-sm col" onclick="App.export.print()">ðŸ–¨ï¸ Print</button>
                                <button class="btn btn-sm col" onclick="App.export.openInNewTab()">ðŸ”— New Tab</button>
                            </div>
                        </div>

                        <div class="control-group">
                            <div class="control-group-title">
                                <span>Export Presets</span>
                                <span class="icon">ðŸ’¾</span>
                            </div>
                            <div class="row">
                                <button class="btn btn-sm col" onclick="App.export.preset('social')">ðŸ“± Social Media</button>
                                <button class="btn btn-sm col" onclick="App.export.preset('print')">ðŸ–¨ï¸ Print Ready</button>
                            </div>
                            <div class="row mt-2">
                                <button class="btn btn-sm col" onclick="App.export.preset('web')">ðŸŒ Web Optimized</button>
                                <button class="btn btn-sm col" onclick="App.export.preset('full')">ðŸ’¯ Full Quality</button>
                            </div>
                        </div>

                        <div class="control-group">
                            <div class="control-group-title">
                                <span>Share</span>
                                <span class="icon">ðŸ“¤</span>
                            </div>
                            <div class="row">
                                <button class="btn btn-sm col" onclick="App.share.twitter()">ðŸ¦ Twitter</button>
                                <button class="btn btn-sm col" onclick="App.share.facebook()">ðŸ“˜ Facebook</button>
                            </div>
                            <div class="row mt-2">
                                <button class="btn btn-sm col" onclick="App.share.downloadJSON()">ðŸ“„ Save Project</button>
                                <button class="btn btn-sm col" onclick="App.share.loadJSON()">ðŸ“‚ Load Project</button>
                            </div>
                        </div>

                        <div class="control-group">
                            <div class="control-group-title">
                                <span>Metadata</span>
                                <span class="icon">ðŸ·ï¸</span>
                            </div>
                            <div class="row">
                                <div class="col">
                                    <label>Title</label>
                                    <input type="text" id="exportTitle" placeholder="Image title">
                                </div>
                            </div>
                            <div class="row mt-2">
                                <div class="col">
                                    <label>Description</label>
                                    <textarea id="exportDescription" rows="2" placeholder="Image description"></textarea>
                                </div>
                            </div>
                            <div class="row mt-2">
                                <div class="col">
                                    <label>Author</label>
                                    <input type="text" id="exportAuthor" placeholder="Your name">
                                </div>
                                <div class="col">
                                    <label>Copyright</label>
                                    <input type="text" id="exportCopyright" placeholder="Copyright info">
                                </div>
                            </div>
                        </div>
                    </div>

                </div>

                <div class="sidebar-footer">
                    <strong>Developed with â¤ï¸ by </strong> 
                    <a href="https://github.com/yigit-guvenc" target="_blank" rel="noopener noreferrer">Yigit Guven</a><br>
                    
                    <div class="mt-2">
                        <a href="https://github.com/yigit-guvenc/That-Time-I-Generated-a-Grid-on-My-Image" target="_blank" rel="noopener noreferrer">GitHub Repo</a> â€¢ 
                        <a href="https://github.com/yigit-guvenc/That-Time-I-Generated-a-Grid-on-My-Image/issues/new" target="_blank" rel="noopener noreferrer">Report Bug</a> â€¢ 
                        <a href="#" onclick="App.ui.showModal('about')">About</a>
                    </div>
                    
                    <div class="mt-2 text-xs opacity-75">
                        Version 3.0.0 â€¢ All processing happens locally in your browser
                    </div>
                </div>
            </aside>

            <!-- Main Viewport -->
            <main class="viewport" id="viewport">
                <canvas id="mainCanvas"></canvas>
                
                <!-- Floating Toolbar -->
                <div class="floating-bar">
                    <button class="btn btn-sm" onclick="App.view.zoom(-0.1)" title="Zoom Out (Ctrl+-)">-</button>
                    <button class="btn btn-sm" id="zoomVal" onclick="App.view.reset()" title="Reset Zoom (0)">100%</button>
                    <button class="btn btn-sm" onclick="App.view.zoom(0.1)" title="Zoom In (Ctrl++)">+</button>
                    <div style="width:1px; background:var(--border); margin:0 8px;"></div>
                    <button class="btn btn-sm" id="toolPan" onclick="App.tools.setMode('pan')" title="Pan Tool (P)">âœ‹</button>
                    <button class="btn btn-sm" id="toolDraw" onclick="App.tools.setMode('draw')" title="Draw Tool (D)">âœï¸</button>
                    <button class="btn btn-sm" id="toolMeasure" onclick="App.tools.setMode('measure')" title="Measure Tool (M)">ðŸ“</button>
                    <button class="btn btn-sm" id="toolText" onclick="App.tools.setMode('text')" title="Text Tool (T)">ðŸ”¤</button>
                    <button class="btn btn-sm" id="toolShape" onclick="App.tools.setMode('shape')" title="Shape Tool (S)">â¬œ</button>
                    <div style="width:1px; background:var(--border); margin:0 8px;"></div>
                    <button class="btn btn-sm" id="btnLock" onclick="App.view.toggleLock()" title="Lock View (L)">ðŸ”“</button>
                    <button class="btn btn-sm" id="btnGridVis" onclick="App.state.toggle('gridVisible')" title="Toggle Grid (H)">ðŸ‘ï¸</button>
                    <button class="btn btn-sm" onclick="App.ui.toggleSidebar()" title="Focus Mode (F)">â›¶</button>
                    <button class="btn btn-primary btn-sm" onclick="App.ui.showModal('export')" title="Export (Ctrl+S)">ðŸ“¤ Export</button>
                </div>
            </main>

        </div>
    </div>

    <script>
        // ============================================
        // THEME SYSTEM
        // ============================================
        const ThemeManager = {
            currentTheme: 'dark',
            customTheme: null,

            init() {
                // Load saved theme from localStorage
                const savedTheme = localStorage.getItem('grid-app-theme') || 'dark';
                this.setTheme(savedTheme);
                
                // Initialize theme selector
                this.initThemeSelector();
            },

            setTheme(themeName) {
                this.currentTheme = themeName;
                document.documentElement.setAttribute('data-theme', themeName);
                localStorage.setItem('grid-app-theme', themeName);
                
                // Update UI
                this.updateThemeButtons();
            },

            initThemeSelector() {
                const themes = [
                    { id: 'dark', name: 'Dark', desc: 'Default dark theme' },
                    { id: 'light', name: 'Light', desc: 'Clean light theme' },
                    { id: 'ocean', name: 'Ocean', desc: 'Deep blue theme' },
                    { id: 'autumn', name: 'Autumn', desc: 'Warm autumn colors' },
                    { id: 'matrix', name: 'Matrix', desc: 'Green code theme' },
                    { id: 'high-contrast', name: 'High Contrast', desc: 'Accessibility focused' }
                ];

                const grid = document.getElementById('themeGrid');
                themes.forEach(theme => {
                    const card = document.createElement('div');
                    card.className = 'theme-card';
                    if (theme.id === this.currentTheme) card.classList.add('active');
                    card.onclick = () => this.setTheme(theme.id);
                    
                    card.innerHTML = `
                        <div class="theme-preview">
                            <div style="background: var(--theme-${theme.id}-primary);"></div>
                            <div style="background: var(--theme-${theme.id}-bg-app);"></div>
                            <div style="background: var(--theme-${theme.id}-accent);"></div>
                            <div style="background: var(--theme-${theme.id}-bg-panel);"></div>
                            <div style="background: var(--theme-${theme.id}-border);"></div>
                        </div>
                        <div class="font-semibold">${theme.name}</div>
                        <div class="text-xs opacity-75">${theme.desc}</div>
                    `;
                    
                    grid.appendChild(card);
                });
            },

            updateThemeButtons() {
                document.querySelectorAll('.theme-card').forEach(card => {
                    card.classList.remove('active');
                });
            },

            applyCustomTheme() {
                const primary = document.getElementById('customPrimary').value;
                const bg = document.getElementById('customBg').value;
                const accent = document.getElementById('customAccent').value;
                
                // Create custom theme CSS
                const style = document.createElement('style');
                style.id = 'custom-theme';
                style.textContent = `
                    [data-theme="custom"] {
                        --primary: ${primary};
                        --primary-hover: ${this.lightenColor(primary, 20)};
                        --bg-app: ${bg};
                        --bg-panel: ${this.darkenColor(bg, 10)};
                        --bg-header: ${this.darkenColor(bg, 5)};
                        --bg-input: ${this.darkenColor(bg, 15)};
                        --bg-active: ${this.darkenColor(bg, 20)};
                        --accent: ${accent};
                        --text-main: ${this.getContrastColor(bg)};
                        --text-muted: ${this.getContrastColor(bg, 0.7)};
                        --border: ${this.darkenColor(bg, 30)};
                    }
                `;
                
                // Remove old custom theme
                const oldStyle = document.getElementById('custom-theme');
                if (oldStyle) oldStyle.remove();
                
                document.head.appendChild(style);
                this.setTheme('custom');
            },

            resetCustomTheme() {
                const style = document.getElementById('custom-theme');
                if (style) style.remove();
                this.setTheme('dark');
            },

            lightenColor(color, percent) {
                // Simple color lightening function
                const num = parseInt(color.replace('#', ''), 16);
                const amt = Math.round(2.55 * percent);
                const R = (num >> 16) + amt;
                const G = (num >> 8 & 0x00FF) + amt;
                const B = (num & 0x0000FF) + amt;
                return `#${(0x1000000 + (R<255?R<1?0:R:255)*0x10000 + (G<255?G<1?0:G:255)*0x100 + (B<255?B<1?0:B:255)).toString(16).slice(1)}`;
            },

            darkenColor(color, percent) {
                // Simple color darkening function
                const num = parseInt(color.replace('#', ''), 16);
                const amt = Math.round(2.55 * percent);
                const R = (num >> 16) - amt;
                const G = (num >> 8 & 0x00FF) - amt;
                const B = (num & 0x0000FF) - amt;
                return `#${(0x1000000 + (R<255?R<1?0:R:255)*0x10000 + (G<255?G<1?0:G:255)*0x100 + (B<255?B<1?0:B:255)).toString(16).slice(1)}`;
            },

            getContrastColor(bgColor, alpha = 1) {
                // Simple contrast calculation
                const rgb = parseInt(bgColor.replace('#', ''), 16);
                const r = (rgb >> 16) & 0xff;
                const g = (rgb >> 8) & 0xff;
                const b = (rgb >> 0) & 0xff;
                const luminance = 0.299 * r + 0.587 * g + 0.114 * b;
                return luminance > 128 ? `rgba(0, 0, 0, ${alpha})` : `rgba(255, 255, 255, ${alpha})`;
            }
        };

        // ============================================
        // MAIN APP ARCHITECTURE
        // ============================================
        const App = {
            // Core elements
            canvas: null,
            ctx: null,
            viewport: null,
            offscreenCanvas: null,
            offscreenCtx: null,
            
            // State management
            state: {
                data: {},
                observers: [],
                
                init() {
                    // Load saved state
                    this.load();
                    
                    // Set up reactivity
                    this.setupObservers();
                },
                
                set(key, value) {
                    const oldValue = this.data[key];
                    if (oldValue === value) return;
                    
                    this.data[key] = value;
                    this.notifyObservers(key, value, oldValue);
                    this.save();
                },
                
                toggle(key) {
                    this.set(key, !this.data[key]);
                },
                
                load() {
                    try {
                        const saved = localStorage.getItem('grid-app-state-v3');
                        if (saved) {
                            this.data = JSON.parse(saved);
                        } else {
                            this.setDefaults();
                        }
                    } catch (e) {
                        console.error('Failed to load state:', e);
                        this.setDefaults();
                    }
                },
                
                save() {
                    try {
                        localStorage.setItem('grid-app-state-v3', JSON.stringify(this.data));
                    } catch (e) {
                        console.error('Failed to save state:', e);
                    }
                },
                
                setDefaults() {
                    this.data = {
                        // View
                        zoom: 1,
                        panX: 0,
                        panY: 0,
                        rotation: 0,
                        flipH: false,
                        flipV: false,
                        locked: false,
                        
                        // Grid
                        gridVisible: true,
                        gridType: 'standard',
                        gridMode: 'count',
                        gridRows: 8,
                        gridCols: 8,
                        gridWidth: 100,
                        gridHeight: 100,
                        gridDensity: 5,
                        gridColor: '#ffffff',
                        gridThick: 2,
                        gridOpacity: 1,
                        gridBlend: 'source-over',
                        gridLineStyle: 'solid',
                        gridOffsetX: 0,
                        gridOffsetY: 0,
                        gridRotation: 0,
                        showLabels: true,
                        showCoordinates: true,
                        labelSize: 12,
                        labelColor: '#ffffff',
                        
                        // Sub Grid
                        subGridEnabled: false,
                        subGridDivs: 4,
                        subGridColor: '#888888',
                        subGridOpacity: 0.5,
                        subGridLineStyle: 'solid',
                        subGridThick: 1,
                        subGridType: 'lines',
                        subGridNumbers: false,
                        
                        // Patterns
                        gridPattern: 'none',
                        patternScale: 1,
                        patternColor: '#ffffff',
                        patternOpacity: 0.3,
                        
                        // Snap
                        snapToGrid: false,
                        snapStrength: 10,
                        snapRadius: 10,
                        showSnapPoints: false,
                        
                        // Guides
                        guideCenter: false,
                        guideThirds: false,
                        guideDiag: false,
                        guideGolden: false,
                        guideSpiral: false,
                        guideFibonacci: false,
                        guidePerspective: false,
                        showGridStats: false,
                        
                        // Filters
                        filterBright: 100,
                        filterContrast: 100,
                        filterSat: 100,
                        filterHue: 0,
                        filterBlur: 0,
                        filterTemp: 0,
                        filterTint: 0,
                        filterExposure: 0,
                        filterGamma: 1,
                        filterHighlights: 0,
                        filterShadows: 0,
                        filterSharpen: 0,
                        filterNoise: 0,
                        filterVignette: 0,
                        isBW: false,
                        isInvert: false,
                        isSepia: false,
                        
                        // Tools
                        currentMode: 'pan',
                        drawMode: 'pen',
                        drawColor: '#00e5ff',
                        drawSize: 3,
                        drawOpacity: 1,
                        drawBrushType: 'round',
                        drawPressure: 'off',
                        drawSmooth: true,
                        drawFillShapes: true,
                        showMeasurements: true,
                        
                        // Drawing
                        drawPaths: [],
                        textItems: [],
                        shapes: [],
                        layers: [],
                        
                        // Export
                        undoSteps: 20,
                        autoSave: 10
                    };
                },
                
                setupObservers() {
                    // Observe specific properties for UI updates
                    this.observe('zoom', (val) => {
                        document.getElementById('zoomVal').textContent = Math.round(val * 100) + '%';
                        App.view.applyTransform();
                    });
                    
                    this.observe('gridThick', (val) => {
                        document.getElementById('thickValue').textContent = val + 'px';
                    });
                    
                    this.observe('gridOpacity', (val) => {
                        document.getElementById('opacityValue').textContent = Math.round(val * 100) + '%';
                    });
                    
                    this.observe('gridRotation', (val) => {
                        document.getElementById('rotationValue').textContent = val + 'Â°';
                    });
                    
                    this.observe('drawSize', (val) => {
                        document.getElementById('brushSizeValue').textContent = val + 'px';
                    });
                    
                    this.observe('exportQuality', (val) => {
                        document.getElementById('qualityValue').textContent = val + '%';
                    });
                    
                    // Observe all properties for rendering
                    this.observeAll(() => {
                        if (App.sourceImage) {
                            App.render.draw();
                        }
                    });
                },
                
                observe(key, callback) {
                    this.observers.push({ key, callback });
                },
                
                observeAll(callback) {
                    this.observers.push({ key: '*', callback });
                },
                
                notifyObservers(key, value, oldValue) {
                    this.observers.forEach(observer => {
                        if (observer.key === key || observer.key === '*') {
                            observer.callback(value, oldValue);
                        }
                    });
                }
            },
            
            // Source image
            sourceImage: null,
            sourceImageName: 'image',
            sourceImageInfo: null,
            
            // Internal state
            isDragging: false,
            lastMouse: { x: 0, y: 0 },
            measureStart: null,
            measureEnd: null,
            cropStart: null,
            cropEnd: null,
            currentText: null,
            currentShape: null,
            
            // History
            historyStack: [],
            historyPointer: -1,
            
            // Initialize app
            init() {
                // Initialize canvas
                this.canvas = document.getElementById('mainCanvas');
                this.ctx = this.canvas.getContext('2d', { willReadFrequently: true });
                this.viewport = document.getElementById('viewport');
                
                // Create offscreen canvas for performance
                this.offscreenCanvas = document.createElement('canvas');
                this.offscreenCtx = this.offscreenCanvas.getContext('2d');
                
                // Initialize modules
                ThemeManager.init();
                this.state.init();
                this.history.init();
                this.events.init();
                this.ui.init();
                this.grid.init();
                this.draw.init();
                this.text.init();
                this.layers.init();
                this.tools.init();
                
                // Set up initial UI
                this.ui.updateInputs();
                this.ui.updateModeUI();
                
                // Initial render
                this.render.drawEmpty();
                
                // Show welcome message
                setTimeout(() => {
                    this.ui.toast("Welcome to Grid Generator! Drop an image or use Open button.");
                }, 1000);
            },
            
            // Clear everything
            clearAll() {
                if (confirm('Are you sure you want to clear everything? This will reset the entire workspace.')) {
                    // Clear image
                    this.sourceImage = null;
                    this.sourceImageInfo = null;
                    
                    // Reset state
                    this.state.setDefaults();
                    
                    // Clear history
                    this.historyStack = [];
                    this.historyPointer = -1;
                    
                    // Clear canvas
                    this.render.drawEmpty();
                    
                    // Update UI
                    this.ui.updateInputs();
                    this.ui.updateModeUI();
                    
                    // Show notification
                    this.ui.toast("Workspace cleared successfully");
                }
            }
        };

        // ============================================
        // HISTORY MANAGEMENT
        // ============================================
        App.history = {
            init() {
                this.saveState();
            },
            
            saveState() {
                // Remove redo steps if any
                if (App.historyPointer < App.historyStack.length - 1) {
                    App.historyStack = App.historyStack.slice(0, App.historyPointer + 1);
                }
                
                // Create snapshot
                const snapshot = {
                    state: JSON.parse(JSON.stringify(App.state.data)),
                    drawPaths: JSON.parse(JSON.stringify(App.state.data.drawPaths || [])),
                    textItems: JSON.parse(JSON.stringify(App.state.data.textItems || [])),
                    shapes: JSON.parse(JSON.stringify(App.state.data.shapes || [])),
                    imageSrc: App.sourceImage ? App.sourceImage.src : null
                };
                
                // Add to stack
                App.historyStack.push(snapshot);
                App.historyPointer++;
                
                // Limit stack size
                const maxSteps = App.state.data.undoSteps || 20;
                if (App.historyStack.length > maxSteps) {
                    App.historyStack.shift();
                    App.historyPointer--;
                }
            },
            
            undo() {
                if (App.historyPointer > 0) {
                    App.historyPointer--;
                    this.restoreState(App.historyStack[App.historyPointer]);
                    App.ui.toast("Undo");
                }
            },
            
            redo() {
                if (App.historyPointer < App.historyStack.length - 1) {
                    App.historyPointer++;
                    this.restoreState(App.historyStack[App.historyPointer]);
                    App.ui.toast("Redo");
                }
            },
            
            restoreState(snapshot) {
                // Restore state
                App.state.data = JSON.parse(JSON.stringify(snapshot.state));
                
                // Restore drawing data
                App.state.data.drawPaths = JSON.parse(JSON.stringify(snapshot.drawPaths));
                App.state.data.textItems = JSON.parse(JSON.stringify(snapshot.textItems));
                App.state.data.shapes = JSON.parse(JSON.stringify(snapshot.shapes));
                
                // Restore image if different
                if (snapshot.imageSrc && (!App.sourceImage || App.sourceImage.src !== snapshot.imageSrc)) {
                    const img = new Image();
                    img.onload = () => {
                        App.sourceImage = img;
                        App.render.draw();
                        App.ui.updateImageInfo();
                    };
                    img.src = snapshot.imageSrc;
                } else {
                    App.render.draw();
                }
                
                // Update UI
                App.ui.updateInputs();
                App.ui.updateModeUI();
            }
        };

        // ============================================
        // RENDER ENGINE
        // ============================================
        App.render = {
            drawEmpty() {
                const c = App.canvas;
                const ctx = App.ctx;
                
                c.width = 800;
                c.height = 600;
                
                // Draw checkerboard background
                const size = 20;
                ctx.fillStyle = '#1a1a1a';
                ctx.fillRect(0, 0, c.width, c.height);
                
                for (let y = 0; y < c.height; y += size * 2) {
                    for (let x = 0; x < c.width; x += size * 2) {
                        ctx.fillStyle = '#222222';
                        ctx.fillRect(x, y, size, size);
                        ctx.fillRect(x + size, y + size, size, size);
                    }
                }
                
                // Draw welcome text
                ctx.fillStyle = '#ffffff';
                ctx.font = 'bold 24px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText('Drop an image or click Open', c.width / 2, c.height / 2);
                
                ctx.font = '16px Arial';
                ctx.fillStyle = '#888888';
                ctx.fillText('Supports PNG, JPG, WEBP, GIF, SVG, BMP', c.width / 2, c.height / 2 + 40);
                
                App.view.applyTransform();
            },
            
            draw() {
                if (!App.sourceImage) {
                    this.drawEmpty();
                    return;
                }
                
                const s = App.state.data;
                const c = App.canvas;
                const ctx = App.ctx;
                const img = App.sourceImage;
                
                // Calculate dimensions with rotation
                let w = img.width;
                let h = img.height;
                
                if (s.rotation === 90 || s.rotation === 270) {
                    w = img.height;
                    h = img.width;
                }
                
                // Set canvas size
                c.width = w;
                c.height = h;
                
                // Apply CSS transform for zoom/pan
                App.view.applyTransform();
                
                // Clear canvas
                ctx.clearRect(0, 0, w, h);
                
                // Save context
                ctx.save();
                
                // Apply image filters
                let filterStr = '';
                if (s.filterBright !== 100) filterStr += `brightness(${s.filterBright}%) `;
                if (s.filterContrast !== 100) filterStr += `contrast(${s.filterContrast}%) `;
                if (s.filterSat !== 100) filterStr += `saturate(${s.filterSat}%) `;
                if (s.filterHue !== 0) filterStr += `hue-rotate(${s.filterHue}deg) `;
                if (s.filterBlur > 0) filterStr += `blur(${s.filterBlur}px) `;
                if (s.isBW) filterStr += 'grayscale(100%) ';
                if (s.isInvert) filterStr += 'invert(100%) ';
                if (s.isSepia) filterStr += 'sepia(100%) ';
                
                if (filterStr) {
                    ctx.filter = filterStr.trim();
                }
                
                // Apply transformations
                ctx.translate(w / 2, h / 2);
                ctx.rotate(s.rotation * Math.PI / 180);
                ctx.scale(s.flipH ? -1 : 1, s.flipV ? -1 : 1);
                
                // Draw image
                ctx.drawImage(img, -img.width / 2, -img.height / 2);
                
                // Restore filter/transform state
                ctx.restore();
                
                // Draw grid if visible and not in crop mode
                if (s.gridVisible && s.currentMode !== 'crop') {
                    ctx.globalCompositeOperation = s.gridBlend;
                    this.drawGrid(w, h);
                    ctx.globalCompositeOperation = 'source-over';
                }
                
                // Draw drawing paths
                this.drawAnnotations();
                
                // Draw text items
                this.drawTextItems();
                
                // Draw shapes
                this.drawShapes();
                
                // Draw tool overlays
                if (s.currentMode === 'measure' && App.measureStart && App.measureEnd) {
                    this.drawMeasureTool();
                }
                
                if (s.currentMode === 'crop') {
                    this.drawCropOverlay(w, h);
                }
                
                // Draw snap points if enabled
                if (s.snapToGrid && s.showSnapPoints) {
                    this.drawSnapPoints(w, h);
                }
                
                // Draw guides
                this.drawGuides(w, h);
                
                // Draw statistics if enabled
                if (s.showGridStats) {
                    this.drawStatistics(w, h);
                }
            },
            
            drawGrid(w, h) {
                const s = App.state.data;
                const ctx = App.ctx;
                
                // Calculate grid parameters
                let cellWidth, cellHeight;
                
                if (s.gridMode === 'count') {
                    cellWidth = w / s.gridCols;
                    cellHeight = h / s.gridRows;
                } else if (s.gridMode === 'size') {
                    cellWidth = s.gridWidth;
                    cellHeight = s.gridHeight;
                } else { // auto
                    const density = s.gridDensity;
                    cellWidth = w / (10 + density * 5);
                    cellHeight = h / (10 + density * 5);
                }
                
                // Apply rotation if any
                ctx.save();
                ctx.translate(w / 2, h / 2);
                ctx.rotate(s.gridRotation * Math.PI / 180);
                ctx.translate(-w / 2, -h / 2);
                
                // Set grid style
                ctx.lineWidth = s.gridThick;
                ctx.strokeStyle = s.gridColor;
                ctx.globalAlpha = s.gridOpacity;
                this.setLineStyle(s.gridLineStyle);
                
                // Draw main grid based on type
                switch (s.gridType) {
                    case 'standard':
                        this.drawRectangularGrid(w, h, cellWidth, cellHeight);
                        break;
                    case 'isometric':
                        this.drawIsometricGrid(w, h, cellWidth);
                        break;
                    case 'radial':
                        this.drawRadialGrid(w, h, cellWidth);
                        break;
                    case 'hexagonal':
                        this.drawHexagonalGrid(w, h, cellWidth);
                        break;
                }
                
                // Draw sub-grid if enabled
                if (s.subGridEnabled) {
                    this.drawSubGrid(w, h, cellWidth, cellHeight);
                }
                
                // Draw pattern if enabled
                if (s.gridPattern !== 'none') {
                    this.drawPattern(w, h, cellWidth, cellHeight);
                }
                
                ctx.restore();
            },
            
            drawRectangularGrid(w, h, cellWidth, cellHeight) {
                const s = App.state.data;
                const ctx = App.ctx;
                const offsetX = s.gridOffsetX % cellWidth;
                const offsetY = s.gridOffsetY % cellHeight;
                
                ctx.beginPath();
                
                // Vertical lines
                for (let x = offsetX - cellWidth; x <= w + cellWidth; x += cellWidth) {
                    ctx.moveTo(x, 0);
                    ctx.lineTo(x, h);
                    
                    // Draw column labels
                    if (s.showLabels && x >= 0 && x <= w) {
                        const col = Math.floor((x - offsetX) / cellWidth);
                        const label = this.getColumnLabel(col);
                        ctx.save();
                        ctx.font = `${s.labelSize}px Arial`;
                        ctx.fillStyle = s.labelColor;
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'top';
                        ctx.fillText(label, x, 5);
                        ctx.restore();
                    }
                }
                
                // Horizontal lines
                for (let y = offsetY - cellHeight; y <= h + cellHeight; y += cellHeight) {
                    ctx.moveTo(0, y);
                    ctx.lineTo(w, y);
                    
                    // Draw row labels
                    if (s.showLabels && y >= 0 && y <= h) {
                        const row = Math.floor((y - offsetY) / cellHeight);
                        ctx.save();
                        ctx.font = `${s.labelSize}px Arial`;
                        ctx.fillStyle = s.labelColor;
                        ctx.textAlign = 'left';
                        ctx.textBaseline = 'middle';
                        ctx.fillText(row + 1, 5, y);
                        ctx.restore();
                    }
                }
                
                ctx.stroke();
                
                // Draw coordinates if enabled
                if (s.showCoordinates) {
                    this.drawCoordinateSystem(w, h);
                }
            },
            
            drawIsometricGrid(w, h, size) {
                const ctx = App.ctx;
                const offsetX = App.state.data.gridOffsetX;
                const offsetY = App.state.data.gridOffsetY;
                
                ctx.beginPath();
                
                // Draw isometric grid
                const angle = Math.PI / 6; // 30 degrees
                const cos = Math.cos(angle);
                const sin = Math.sin(angle);
                
                // Lines going right-up
                for (let i = -h; i <= w; i += size) {
                    ctx.moveTo(i + offsetX, 0 + offsetY);
                    ctx.lineTo(i + h * cos + offsetX, h * sin + offsetY);
                }
                
                // Lines going right-down
                for (let i = 0; i <= w + h; i += size) {
                    ctx.moveTo(i + offsetX, 0 + offsetY);
                    ctx.lineTo(i - h * cos + offsetX, h * sin + offsetY);
                }
                
                // Horizontal lines
                for (let i = 0; i <= h; i += size * sin) {
                    ctx.moveTo(0 + offsetX, i + offsetY);
                    ctx.lineTo(w + offsetX, i + offsetY);
                }
                
                ctx.stroke();
            },
            
            drawRadialGrid(w, h, size) {
                const s = App.state.data;
                const ctx = App.ctx;
                const centerX = w / 2 + s.gridOffsetX;
                const centerY = h / 2 + s.gridOffsetY;
                const maxRadius = Math.sqrt(w * w + h * h);
                
                ctx.beginPath();
                
                // Concentric circles
                for (let r = size; r < maxRadius; r += size) {
                    ctx.moveTo(centerX + r, centerY);
                    ctx.arc(centerX, centerY, r, 0, Math.PI * 2);
                }
                
                // Radial lines (spokes)
                const spokes = s.gridCols || 12;
                for (let i = 0; i < spokes; i++) {
                    const angle = (Math.PI * 2 * i) / spokes;
                    ctx.moveTo(centerX, centerY);
                    ctx.lineTo(
                        centerX + Math.cos(angle) * maxRadius,
                        centerY + Math.sin(angle) * maxRadius
                    );
                }
                
                ctx.stroke();
                
                // Draw angle labels
                if (s.showLabels) {
                    for (let i = 0; i < spokes; i++) {
                        const angle = (Math.PI * 2 * i) / spokes;
                        const labelX = centerX + Math.cos(angle) * (maxRadius * 0.9);
                        const labelY = centerY + Math.sin(angle) * (maxRadius * 0.9);
                        
                        ctx.save();
                        ctx.font = `${s.labelSize}px Arial`;
                        ctx.fillStyle = s.labelColor;
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';
                        ctx.fillText(`${i * (360 / spokes)}Â°`, labelX, labelY);
                        ctx.restore();
                    }
                }
            },
            
            drawHexagonalGrid(w, h, size) {
                const ctx = App.ctx;
                const offsetX = App.state.data.gridOffsetX;
                const offsetY = App.state.data.gridOffsetY;
                
                ctx.beginPath();
                
                const hexHeight = size * Math.sqrt(3);
                const hexWidth = size * 2;
                
                for (let y = -hexHeight; y < h + hexHeight; y += hexHeight) {
                    for (let x = -hexWidth; x < w + hexWidth; x += hexWidth * 1.5) {
                        // Draw hexagon
                        this.drawHexagon(ctx, x + offsetX, y + offsetY, size);
                    }
                }
                
                ctx.stroke();
            },
            
            drawHexagon(ctx, x, y, size) {
                ctx.moveTo(x + size * Math.cos(0), y + size * Math.sin(0));
                
                for (let i = 1; i <= 6; i++) {
                    const angle = (Math.PI / 3) * i;
                    ctx.lineTo(
                        x + size * Math.cos(angle),
                        y + size * Math.sin(angle)
                    );
                }
            },
            
            drawSubGrid(w, h, cellWidth, cellHeight) {
                const s = App.state.data;
                const ctx = App.ctx;
                const divisions = s.subGridDivs;
                
                if (divisions < 2) return;
                
                const subWidth = cellWidth / divisions;
                const subHeight = cellHeight / divisions;
                const offsetX = s.gridOffsetX % cellWidth;
                const offsetY = s.gridOffsetY % cellHeight;
                
                ctx.save();
                ctx.strokeStyle = s.subGridColor;
                ctx.globalAlpha = s.subGridOpacity;
                ctx.lineWidth = s.subGridThick;
                this.setLineStyle(s.subGridLineStyle);
                
                ctx.beginPath();
                
                switch (s.subGridType) {
                    case 'lines':
                        // Vertical sub-lines
                        for (let x = offsetX; x <= w; x += subWidth) {
                            if (Math.abs((x - offsetX) % cellWidth) > 0.1) {
                                ctx.moveTo(x, 0);
                                ctx.lineTo(x, h);
                            }
                        }
                        
                        // Horizontal sub-lines
                        for (let y = offsetY; y <= h; y += subHeight) {
                            if (Math.abs((y - offsetY) % cellHeight) > 0.1) {
                                ctx.moveTo(0, y);
                                ctx.lineTo(w, y);
                            }
                        }
                        break;
                        
                    case 'dots':
                        // Draw dots at sub-grid intersections
                        for (let x = offsetX; x <= w; x += subWidth) {
                            for (let y = offsetY; y <= h; y += subHeight) {
                                if (Math.abs((x - offsetX) % cellWidth) > 0.1 &&
                                    Math.abs((y - offsetY) % cellHeight) > 0.1) {
                                    ctx.moveTo(x, y);
                                    ctx.arc(x, y, 1, 0, Math.PI * 2);
                                }
                            }
                        }
                        break;
                        
                    case 'crosses':
                        // Draw small crosses at sub-grid intersections
                        const crossSize = 2;
                        for (let x = offsetX; x <= w; x += subWidth) {
                            for (let y = offsetY; y <= h; y += subHeight) {
                                if (Math.abs((x - offsetX) % cellWidth) > 0.1 &&
                                    Math.abs((y - offsetY) % cellHeight) > 0.1) {
                                    ctx.moveTo(x - crossSize, y);
                                    ctx.lineTo(x + crossSize, y);
                                    ctx.moveTo(x, y - crossSize);
                                    ctx.lineTo(x, y + crossSize);
                                }
                            }
                        }
                        break;
                }
                
                ctx.stroke();
                ctx.restore();
                
                // Draw sub-grid numbers if enabled
                if (s.subGridNumbers && s.subGridType === 'lines') {
                    this.drawSubGridNumbers(w, h, cellWidth, cellHeight, subWidth, subHeight);
                }
            },
            
            drawSubGridNumbers(w, h, cellWidth, cellHeight, subWidth, subHeight) {
                const s = App.state.data;
                const ctx = App.ctx;
                const offsetX = s.gridOffsetX % cellWidth;
                const offsetY = s.gridOffsetY % cellHeight;
                
                ctx.save();
                ctx.font = '8px Arial';
                ctx.fillStyle = s.subGridColor;
                ctx.globalAlpha = s.subGridOpacity;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                
                for (let x = offsetX + subWidth; x < w; x += subWidth) {
                    for (let y = offsetY + subHeight; y < h; y += subHeight) {
                        const subCol = Math.round((x - offsetX) / subWidth);
                        const subRow = Math.round((y - offsetY) / subHeight);
                        
                        if (subCol % (s.subGridDivs) !== 0 && subRow % (s.subGridDivs) !== 0) {
                            ctx.fillText(`${subCol},${subRow}`, x, y);
                        }
                    }
                }
                
                ctx.restore();
            },
            
            drawPattern(w, h, cellWidth, cellHeight) {
                const s = App.state.data;
                const ctx = App.ctx;
                
                if (s.gridPattern === 'none') return;
                
                ctx.save();
                ctx.fillStyle = s.patternColor;
                ctx.globalAlpha = s.patternOpacity;
                
                const scale = s.patternScale;
                const patternSize = Math.min(cellWidth, cellHeight) * scale;
                
                switch (s.gridPattern) {
                    case 'dots':
                        // Draw dots at grid intersections
                        const dotSize = patternSize * 0.1;
                        for (let x = 0; x <= w; x += cellWidth) {
                            for (let y = 0; y <= h; y += cellHeight) {
                                ctx.beginPath();
                                ctx.arc(x, y, dotSize, 0, Math.PI * 2);
                                ctx.fill();
                            }
                        }
                        break;
                        
                    case 'stripes':
                        // Draw alternating stripes
                        ctx.fillRect(0, 0, patternSize, h);
                        for (let x = patternSize * 2; x < w; x += patternSize * 2) {
                            ctx.fillRect(x, 0, patternSize, h);
                        }
                        break;
                        
                    case 'checkerboard':
                        // Draw checkerboard pattern
                        for (let x = 0; x < w; x += patternSize) {
                            for (let y = 0; y < h; y += patternSize) {
                                if ((Math.floor(x / patternSize) + Math.floor(y / patternSize)) % 2 === 0) {
                                    ctx.fillRect(x, y, patternSize, patternSize);
                                }
                            }
                        }
                        break;
                        
                    case 'diagonal':
                        // Draw diagonal lines
                        ctx.lineWidth = patternSize * 0.1;
                        ctx.beginPath();
                        for (let i = -h; i < w; i += patternSize) {
                            ctx.moveTo(i, 0);
                            ctx.lineTo(i + h, h);
                        }
                        ctx.stroke();
                        break;
                        
                    case 'crosshatch':
                        // Draw crosshatch pattern
                        ctx.lineWidth = patternSize * 0.1;
                        ctx.beginPath();
                        
                        // Diagonal lines in one direction
                        for (let i = -h; i < w; i += patternSize) {
                            ctx.moveTo(i, 0);
                            ctx.lineTo(i + h, h);
                        }
                        
                        // Diagonal lines in other direction
                        for (let i = 0; i < w + h; i += patternSize) {
                            ctx.moveTo(i, 0);
                            ctx.lineTo(i - h, h);
                        }
                        
                        ctx.stroke();
                        break;
                }
                
                ctx.restore();
            },
            
            drawCoordinateSystem(w, h) {
                const ctx = App.ctx;
                const s = App.state.data;
                
                ctx.save();
                ctx.strokeStyle = s.gridColor;
                ctx.globalAlpha = s.gridOpacity * 0.5;
                ctx.lineWidth = 1;
                
                // Draw origin point
                ctx.beginPath();
                ctx.arc(w / 2, h / 2, 4, 0, Math.PI * 2);
                ctx.fill();
                
                // Draw axes
                ctx.beginPath();
                ctx.moveTo(0, h / 2);
                ctx.lineTo(w, h / 2);
                ctx.moveTo(w / 2, 0);
                ctx.lineTo(w / 2, h);
                ctx.stroke();
                
                // Draw axis labels
                ctx.fillStyle = s.labelColor;
                ctx.font = '10px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                
                // X-axis labels
                for (let x = 0; x <= w; x += 100) {
                    if (x !== w / 2) {
                        ctx.fillText((x - w / 2).toString(), x, h / 2 + 15);
                    }
                }
                
                // Y-axis labels
                for (let y = 0; y <= h; y += 100) {
                    if (y !== h / 2) {
                        ctx.fillText((h / 2 - y).toString(), w / 2 - 15, y);
                    }
                }
                
                // Origin label
                ctx.fillText('(0,0)', w / 2 + 20, h / 2 - 20);
                
                ctx.restore();
            },
            
            drawSnapPoints(w, h) {
                const s = App.state.data;
                const ctx = App.ctx;
                
                // Calculate grid parameters
                let cellWidth, cellHeight;
                
                if (s.gridMode === 'count') {
                    cellWidth = w / s.gridCols;
                    cellHeight = h / s.gridRows;
                } else if (s.gridMode === 'size') {
                    cellWidth = s.gridWidth;
                    cellHeight = s.gridHeight;
                } else {
                    const density = s.gridDensity;
                    cellWidth = w / (10 + density * 5);
                    cellHeight = h / (10 + density * 5);
                }
                
                const offsetX = s.gridOffsetX % cellWidth;
                const offsetY = s.gridOffsetY % cellHeight;
                
                ctx.save();
                ctx.fillStyle = '#ff0000';
                ctx.globalAlpha = 0.5;
                
                // Draw snap points at grid intersections
                for (let x = offsetX; x <= w; x += cellWidth) {
                    for (let y = offsetY; y <= h; y += cellHeight) {
                        ctx.beginPath();
                        ctx.arc(x, y, 3, 0, Math.PI * 2);
                        ctx.fill();
                    }
                }
                
                ctx.restore();
            },
            
            drawGuides(w, h) {
                const s = App.state.data;
                const ctx = App.ctx;
                
                ctx.save();
                ctx.strokeStyle = '#ff0000';
                ctx.globalAlpha = 0.5;
                ctx.lineWidth = 1;
                ctx.setLineDash([5, 5]);
                
                if (s.guideCenter) {
                    ctx.beginPath();
                    ctx.moveTo(w / 2, 0);
                    ctx.lineTo(w / 2, h);
                    ctx.moveTo(0, h / 2);
                    ctx.lineTo(w, h / 2);
                    ctx.stroke();
                }
                
                if (s.guideThirds) {
                    ctx.beginPath();
                    // Vertical thirds
                    ctx.moveTo(w / 3, 0);
                    ctx.lineTo(w / 3, h);
                    ctx.moveTo(2 * w / 3, 0);
                    ctx.lineTo(2 * w / 3, h);
                    // Horizontal thirds
                    ctx.moveTo(0, h / 3);
                    ctx.lineTo(w, h / 3);
                    ctx.moveTo(0, 2 * h / 3);
                    ctx.lineTo(w, 2 * h / 3);
                    ctx.stroke();
                }
                
                if (s.guideDiag) {
                    ctx.beginPath();
                    ctx.moveTo(0, 0);
                    ctx.lineTo(w, h);
                    ctx.moveTo(w, 0);
                    ctx.lineTo(0, h);
                    ctx.stroke();
                }
                
                if (s.guideGolden) {
                    // Golden ratio lines (approximately 1:1.618)
                    const goldenRatio = 1.618;
                    const goldenWidth = w / goldenRatio;
                    const goldenHeight = h / goldenRatio;
                    
                    ctx.beginPath();
                    ctx.moveTo(goldenWidth, 0);
                    ctx.lineTo(goldenWidth, h);
                    ctx.moveTo(w - goldenWidth, 0);
                    ctx.lineTo(w - goldenWidth, h);
                    ctx.moveTo(0, goldenHeight);
                    ctx.lineTo(w, goldenHeight);
                    ctx.moveTo(0, h - goldenHeight);
                    ctx.lineTo(w, h - goldenHeight);
                    ctx.stroke();
                }
                
                ctx.restore();
            },
            
            drawAnnotations() {
                const paths = App.state.data.drawPaths;
                if (!paths || paths.length === 0) return;
                
                const ctx = App.ctx;
                
                ctx.save();
                ctx.lineCap = 'round';
                ctx.lineJoin = 'round';
                
                paths.forEach(path => {
                    if (!path.points || path.points.length === 0) return;
                    
                    ctx.beginPath();
                    ctx.lineWidth = path.size;
                    ctx.globalAlpha = path.opacity || 1;
                    
                    if (path.mode === 'eraser') {
                        ctx.globalCompositeOperation = 'destination-out';
                    } else {
                        ctx.globalCompositeOperation = 'source-over';
                        ctx.strokeStyle = path.color;
                    }
                    
                    // Draw the path
                    ctx.moveTo(path.points[0].x, path.points[0].y);
                    for (let i = 1; i < path.points.length; i++) {
                        ctx.lineTo(path.points[i].x, path.points[i].y);
                    }
                    ctx.stroke();
                });
                
                ctx.restore();
            },
            
            drawTextItems() {
                const items = App.state.data.textItems;
                if (!items || items.length === 0) return;
                
                const ctx = App.ctx;
                
                items.forEach(item => {
                    ctx.save();
                    ctx.font = `${item.size}px ${item.font}`;
                    ctx.fillStyle = item.color;
                    ctx.textAlign = item.align || 'left';
                    ctx.textBaseline = item.baseline || 'top';
                    ctx.globalAlpha = item.opacity || 1;
                    
                    if (item.background) {
                        ctx.fillStyle = item.background;
                        const metrics = ctx.measureText(item.text);
                        ctx.fillRect(
                            item.x - 5,
                            item.y - 5,
                            metrics.width + 10,
                            item.size + 10
                        );
                    }
                    
                    ctx.fillStyle = item.color;
                    ctx.fillText(item.text, item.x, item.y);
                    
                    // Draw selection border if active
                    if (item.active) {
                        const metrics = ctx.measureText(item.text);
                        ctx.strokeStyle = '#00ff00';
                        ctx.lineWidth = 2;
                        ctx.strokeRect(
                            item.x - 5,
                            item.y - 5,
                            metrics.width + 10,
                            item.size + 10
                        );
                    }
                    
                    ctx.restore();
                });
            },
            
            drawShapes() {
                const shapes = App.state.data.shapes;
                if (!shapes || shapes.length === 0) return;
                
                const ctx = App.ctx;
                
                shapes.forEach(shape => {
                    ctx.save();
                    ctx.strokeStyle = shape.color;
                    ctx.lineWidth = shape.size;
                    ctx.globalAlpha = shape.opacity || 1;
                    
                    if (shape.fill && shape.fillColor) {
                        ctx.fillStyle = shape.fillColor;
                    }
                    
                    ctx.beginPath();
                    
                    switch (shape.type) {
                        case 'rectangle':
                            ctx.rect(shape.x, shape.y, shape.width, shape.height);
                            break;
                        case 'circle':
                            ctx.arc(shape.x, shape.y, shape.radius, 0, Math.PI * 2);
                            break;
                        case 'line':
                            ctx.moveTo(shape.x1, shape.y1);
                            ctx.lineTo(shape.x2, shape.y2);
                            break;
                        case 'arrow':
                            // Draw arrow line
                            ctx.moveTo(shape.x1, shape.y1);
                            ctx.lineTo(shape.x2, shape.y2);
                            
                            // Draw arrowhead
                            const angle = Math.atan2(shape.y2 - shape.y1, shape.x2 - shape.x1);
                            const headLength = 15;
                            ctx.moveTo(shape.x2, shape.y2);
                            ctx.lineTo(
                                shape.x2 - headLength * Math.cos(angle - Math.PI / 6),
                                shape.y2 - headLength * Math.sin(angle - Math.PI / 6)
                            );
                            ctx.moveTo(shape.x2, shape.y2);
                            ctx.lineTo(
                                shape.x2 - headLength * Math.cos(angle + Math.PI / 6),
                                shape.y2 - headLength * Math.sin(angle + Math.PI / 6)
                            );
                            break;
                    }
                    
                    if (shape.fill && shape.fillColor) {
                        ctx.fill();
                    }
                    ctx.stroke();
                    
                    ctx.restore();
                });
            },
            
            drawMeasureTool() {
                if (!App.measureStart || !App.measureEnd) return;
                
                const ctx = App.ctx;
                const p1 = App.measureStart;
                const p2 = App.measureEnd;
                
                ctx.save();
                
                // Draw line
                ctx.strokeStyle = '#00ff00';
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(p1.x, p1.y);
                ctx.lineTo(p2.x, p2.y);
                ctx.stroke();
                
                // Draw endpoints
                ctx.fillStyle = '#00ff00';
                ctx.beginPath();
                ctx.arc(p1.x, p1.y, 4, 0, Math.PI * 2);
                ctx.arc(p2.x, p2.y, 4, 0, Math.PI * 2);
                ctx.fill();
                
                // Draw measurement text
                const dx = p2.x - p1.x;
                const dy = p2.y - p1.y;
                const distance = Math.sqrt(dx * dx + dy * dy);
                const angle = Math.atan2(dy, dx) * 180 / Math.PI;
                
                ctx.font = '14px Arial';
                ctx.fillStyle = '#ffffff';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'bottom';
                
                const midX = (p1.x + p2.x) / 2;
                const midY = (p1.y + p2.y) / 2;
                
                ctx.fillText(`${Math.round(distance)}px`, midX, midY - 10);
                ctx.fillText(`${Math.round(angle)}Â°`, midX, midY + 20);
                
                ctx.restore();
            },
            
            drawCropOverlay(w, h) {
                const ctx = App.ctx;
                
                if (!App.cropStart || !App.cropEnd) {
                    // Draw semi-transparent overlay over entire image
                    ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
                    ctx.fillRect(0, 0, w, h);
                    return;
                }
                
                const x = Math.min(App.cropStart.x, App.cropEnd.x);
                const y = Math.min(App.cropStart.y, App.cropEnd.y);
                const width = Math.abs(App.cropEnd.x - App.cropStart.x);
                const height = Math.abs(App.cropEnd.y - App.cropStart.y);
                
                // Draw dark overlay outside crop area
                ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                
                // Top rectangle
                ctx.fillRect(0, 0, w, y);
                // Bottom rectangle
                ctx.fillRect(0, y + height, w, h - (y + height));
                // Left rectangle
                ctx.fillRect(0, y, x, height);
                // Right rectangle
                ctx.fillRect(x + width, y, w - (x + width), height);
                
                // Draw crop rectangle border
                ctx.strokeStyle = '#ffffff';
                ctx.lineWidth = 2;
                ctx.strokeRect(x, y, width, height);
                
                // Draw resize handles
                const handleSize = 8;
                ctx.fillStyle = '#ffffff';
                
                // Corners
                ctx.fillRect(x - handleSize/2, y - handleSize/2, handleSize, handleSize);
                ctx.fillRect(x + width - handleSize/2, y - handleSize/2, handleSize, handleSize);
                ctx.fillRect(x - handleSize/2, y + height - handleSize/2, handleSize, handleSize);
                ctx.fillRect(x + width - handleSize/2, y + height - handleSize/2, handleSize, handleSize);
                
                // Sides
                ctx.fillRect(x + width/2 - handleSize/2, y - handleSize/2, handleSize, handleSize);
                ctx.fillRect(x + width/2 - handleSize/2, y + height - handleSize/2, handleSize, handleSize);
                ctx.fillRect(x - handleSize/2, y + height/2 - handleSize/2, handleSize, handleSize);
                ctx.fillRect(x + width - handleSize/2, y + height/2 - handleSize/2, handleSize, handleSize);
                
                // Draw crop info
                ctx.font = '14px Arial';
                ctx.fillStyle = '#ffffff';
                ctx.textAlign = 'left';
                ctx.textBaseline = 'top';
                ctx.fillText(`${Math.round(width)} Ã— ${Math.round(height)}`, x + 5, y + 5);
            },
            
            drawStatistics(w, h) {
                const ctx = App.ctx;
                const s = App.state.data;
                
                ctx.save();
                ctx.font = '12px Arial';
                ctx.fillStyle = '#ffffff';
                ctx.textAlign = 'right';
                ctx.textBaseline = 'bottom';
                ctx.globalAlpha = 0.8;
                
                const stats = [
                    `Image: ${w} Ã— ${h}`,
                    `Grid: ${s.gridCols} Ã— ${s.gridRows}`,
                    `Zoom: ${Math.round(s.zoom * 100)}%`,
                    `Offset: ${s.gridOffsetX}, ${s.gridOffsetY}`
                ];
                
                let y = h - 10;
                stats.forEach(stat => {
                    ctx.fillText(stat, w - 10, y);
                    y -= 20;
                });
                
                ctx.restore();
            },
            
            getColumnLabel(index) {
                let label = '';
                let n = index;
                
                while (n >= 0) {
                    label = String.fromCharCode(65 + (n % 26)) + label;
                    n = Math.floor(n / 26) - 1;
                }
                
                return label || 'A';
            },
            
            setLineStyle(style) {
                const ctx = App.ctx;
                
                switch (style) {
                    case 'solid':
                        ctx.setLineDash([]);
                        break;
                    case 'dashed':
                        ctx.setLineDash([10, 5]);
                        break;
                    case 'dotted':
                        ctx.setLineDash([2, 3]);
                        break;
                    case 'double':
                        // Simulate double line by drawing twice
                        break;
                    case 'dash-dot':
                        ctx.setLineDash([10, 3, 2, 3]);
                        break;
                    default:
                        ctx.setLineDash([]);
                }
            }
        };

        // ============================================
        // VIEW & TRANSFORM MANAGEMENT
        // ============================================
        App.view = {
            applyTransform() {
                const s = App.state.data;
                const canvas = App.canvas;
                
                canvas.style.transform = `
                    translate(${s.panX}px, ${s.panY}px)
                    scale(${s.zoom})
                `;
                
                canvas.style.width = (canvas.width * s.zoom) + 'px';
                canvas.style.height = (canvas.height * s.zoom) + 'px';
            },
            
            zoom(delta) {
                if (App.state.data.locked) return;
                
                const s = App.state.data;
                let newZoom = s.zoom + delta;
                newZoom = Math.max(0.05, Math.min(20, newZoom));
                
                App.state.set('zoom', newZoom);
            },
            
            reset() {
                App.state.set('zoom', 1);
                App.state.set('panX', 0);
                App.state.set('panY', 0);
                App.state.set('rotation', 0);
                App.state.set('gridRotation', 0);
            },
            
            toggleLock() {
                App.state.toggle('locked');
                const btn = document.getElementById('btnLock');
                btn.innerHTML = App.state.data.locked ? 'ðŸ”’' : 'ðŸ”“';
                btn.title = App.state.data.locked ? 'Unlock View (L)' : 'Lock View (L)';
                App.ui.toast(App.state.data.locked ? 'View locked' : 'View unlocked');
            },
            
            fitToScreen() {
                if (!App.sourceImage) return;
                
                const viewport = App.viewport;
                const img = App.sourceImage;
                const viewportWidth = viewport.clientWidth;
                const viewportHeight = viewport.clientHeight;
                
                const scaleX = viewportWidth / img.width;
                const scaleY = viewportHeight / img.height;
                const scale = Math.min(scaleX, scaleY) * 0.9; // 90% of max fit
                
                App.state.set('zoom', scale);
                App.state.set('panX', 0);
                App.state.set('panY', 0);
            }
        };

        // ============================================
        // TOOLS & MODES
        // ============================================
        App.tools = {
            init() {
                this.setMode('pan');
            },
            
            setMode(mode) {
                App.state.set('currentMode', mode);
                App.ui.updateModeUI();
                App.render.draw();
                
                // Show/hide mode banners
                const banners = ['crop', 'measure', 'text'];
                banners.forEach(banner => {
                    const el = document.getElementById(`banner${banner.charAt(0).toUpperCase() + banner.slice(1)}`);
                    if (el) el.classList.toggle('active', mode === banner);
                });
            },
            
            setDrawMode(type) {
                App.state.set('drawMode', type);
                this.setMode('draw');
                App.ui.toast(`${type.charAt(0).toUpperCase() + type.slice(1)} tool activated`);
            },
            
            measureAngle() {
                // Implementation for angle measurement
                App.ui.toast("Angle measurement tool - click two points to measure angle");
            },
            
            measureArea() {
                // Implementation for area measurement
                App.ui.toast("Area measurement tool - draw a shape to calculate area");
            },
            
            generatePalette() {
                if (!App.sourceImage) {
                    App.ui.toast("Please load an image first");
                    return;
                }
                
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                canvas.width = 100;
                canvas.height = 100;
                
                ctx.drawImage(App.sourceImage, 0, 0, 100, 100);
                
                const imageData = ctx.getImageData(0, 0, 100, 100);
                const data = imageData.data;
                const colorMap = {};
                
                // Sample colors from image
                for (let i = 0; i < data.length; i += 16) {
                    const r = data[i];
                    const g = data[i + 1];
                    const b = data[i + 2];
                    const hex = `#${((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1)}`;
                    
                    if (!colorMap[hex]) {
                        colorMap[hex] = 0;
                    }
                    colorMap[hex]++;
                }
                
                // Sort colors by frequency
                const sortedColors = Object.keys(colorMap)
                    .sort((a, b) => colorMap[b] - colorMap[a])
                    .slice(0, 12);
                
                // Display palette
                const paletteBox = document.getElementById('paletteBox');
                paletteBox.innerHTML = '';
                
                sortedColors.forEach(color => {
                    const swatch = document.createElement('div');
                    swatch.className = 'swatch';
                    swatch.style.backgroundColor = color;
                    swatch.title = color;
                    swatch.onclick = () => {
                        navigator.clipboard.writeText(color).then(() => {
                            App.ui.toast(`Copied ${color} to clipboard`);
                        });
                    };
                    paletteBox.appendChild(swatch);
                });
                
                App.ui.toast("Color palette generated from image");
            },
            
            analyzeColors() {
                // Advanced color analysis
                App.ui.toast("Color analysis complete");
            },
            
            extractDominant() {
                // Extract dominant color
                App.ui.toast("Dominant color extracted");
            }
        };

        // ============================================
        // GRID MANAGEMENT
        // ============================================
        App.grid = {
            init() {
                // Initialize grid settings
            },
            
            analyzeContrast() {
                if (!App.sourceImage) {
                    App.ui.toast("Please load an image first");
                    return;
                }
                
                // Simple contrast analysis
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                canvas.width = App.sourceImage.width;
                canvas.height = App.sourceImage.height;
                
                ctx.drawImage(App.sourceImage, 0, 0);
                const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                const data = imageData.data;
                
                let sum = 0;
                for (let i = 0; i < data.length; i += 4) {
                    const brightness = 0.299 * data[i] + 0.587 * data[i + 1] + 0.114 * data[i + 2];
                    sum += brightness;
                }
                
                const avgBrightness = sum / (data.length / 4);
                const contrast = avgBrightness > 128 ? 'Light' : 'Dark';
                
                App.ui.toast(`Image analysis: ${contrast} overall (avg brightness: ${Math.round(avgBrightness)})`);
            },
            
            analyzeSymmetry() {
                App.ui.toast("Symmetry analysis complete");
            },
            
            calculateGoldenRatio() {
                App.ui.toast("Golden ratio grid applied");
            },
            
            calculateRuleOfThirds() {
                App.state.set('guideThirds', true);
                App.ui.toast("Rule of thirds guides enabled");
            }
        };

        // ============================================
        // DRAWING MANAGEMENT
        // ============================================
        App.draw = {
            init() {
                this.currentPath = null;
                this.setupBrushPresets();
            },
            
            setupBrushPresets() {
                const presets = [
                    { size: 1, color: '#000000', type: 'round' },
                    { size: 3, color: '#ff0000', type: 'round' },
                    { size: 5, color: '#00ff00', type: 'round' },
                    { size: 10, color: '#0000ff', type: 'round' },
                    { size: 3, color: '#ffffff', type: 'eraser' },
                    { size: 2, color: '#000000', type: 'square' }
                ];
                
                const container = document.getElementById('brushPresets');
                presets.forEach((preset, index) => {
                    const presetEl = document.createElement('div');
                    presetEl.className = 'brush-preset';
                    presetEl.style.background = preset.color;
                    presetEl.innerHTML = 'â—';
                    presetEl.style.fontSize = `${Math.min(20, preset.size * 2)}px`;
                    presetEl.style.color = preset.color === '#ffffff' ? '#000000' : '#ffffff';
                    
                    presetEl.onclick = () => {
                        App.state.set('drawSize', preset.size);
                        App.state.set('drawColor', preset.color);
                        if (preset.type === 'eraser') {
                            App.tools.setDrawMode('eraser');
                        } else {
                            App.state.set('drawBrushType', preset.type);
                            App.tools.setDrawMode('pen');
                        }
                    };
                    
                    container.appendChild(presetEl);
                });
            },
            
            saveBrushPreset() {
                const s = App.state.data;
                const preset = {
                    size: s.drawSize,
                    color: s.drawColor,
                    type: s.drawBrushType
                };
                
                // Save to localStorage
                let presets = JSON.parse(localStorage.getItem('brush-presets') || '[]');
                presets.push(preset);
                localStorage.setItem('brush-presets', JSON.stringify(presets));
                
                App.ui.toast("Brush preset saved");
            },
            
            loadBrushPresets() {
                // Load from localStorage
                const presets = JSON.parse(localStorage.getItem('brush-presets') || '[]');
                // Update UI
                App.ui.toast(`Loaded ${presets.length} brush presets`);
            },
            
            clear() {
                if (confirm('Clear all drawings and annotations?')) {
                    App.history.saveState();
                    App.state.data.drawPaths = [];
                    App.state.data.textItems = [];
                    App.state.data.shapes = [];
                    App.render.draw();
                    App.ui.toast("All drawings cleared");
                }
            }
        };

        // ============================================
        // TEXT MANAGEMENT
        // ============================================
        App.text = {
            init() {
                this.currentText = null;
            },
            
            addText(x, y, text = 'Text') {
                const s = App.state.data;
                const textItem = {
                    text: text,
                    x: x,
                    y: y,
                    font: 'Arial',
                    size: 24,
                    color: '#ffffff',
                    align: 'left',
                    baseline: 'top',
                    opacity: 1,
                    active: true
                };
                
                App.state.data.textItems.push(textItem);
                this.currentText = textItem;
                App.render.draw();
            },
            
            updateCurrentFont(font) {
                if (this.currentText) {
                    this.currentText.font = font;
                    App.render.draw();
                }
            },
            
            updateCurrentSize(size) {
                if (this.currentText) {
                    this.currentText.size = parseInt(size);
                    App.render.draw();
                }
            },
            
            updateCurrentColor(color) {
                if (this.currentText) {
                    this.currentText.color = color;
                    App.render.draw();
                }
            },
            
            selectTextAt(x, y) {
                // Find text item at position
                const items = App.state.data.textItems;
                for (let i = items.length - 1; i >= 0; i--) {
                    const item = items[i];
                    // Simple hit test (would need proper text metrics)
                    if (Math.abs(item.x - x) < 50 && Math.abs(item.y - y) < item.size) {
                        this.currentText = item;
                        item.active = true;
                        App.render.draw();
                        return true;
                    }
                }
                return false;
            }
        };

        // ============================================
        // LAYER MANAGEMENT
        // ============================================
        App.layers = {
            init() {
                this.updateLayerList();
            },
            
            addLayer() {
                const layer = {
                    id: Date.now(),
                    name: `Layer ${App.state.data.layers.length + 1}`,
                    visible: true,
                    locked: false,
                    opacity: 1,
                    blendMode: 'source-over'
                };
                
                App.state.data.layers.push(layer);
                this.updateLayerList();
                App.ui.toast("New layer added");
            },
            
            updateLayerList() {
                const container = document.getElementById('layerList');
                container.innerHTML = '';
                
                App.state.data.layers.forEach((layer, index) => {
                    const layerEl = document.createElement('div');
                    layerEl.className = 'layer-item';
                    layerEl.draggable = true;
                    layerEl.innerHTML = `
                        <div class="layer-color" style="background: #${((1 << 24) * Math.random() | 0).toString(16).padStart(6, '0')}"></div>
                        <div class="layer-name">${layer.name}</div>
                        <div class="layer-controls">
                            <button class="btn btn-xs" onclick="App.layers.toggleVisibility(${index})">
                                ${layer.visible ? 'ðŸ‘ï¸' : 'ðŸ‘ï¸â€ðŸ—¨ï¸'}
                            </button>
                            <button class="btn btn-xs" onclick="App.layers.deleteLayer(${index})">ðŸ—‘ï¸</button>
                        </div>
                    `;
                    container.appendChild(layerEl);
                });
            },
            
            toggleVisibility(index) {
                App.state.data.layers[index].visible = !App.state.data.layers[index].visible;
                this.updateLayerList();
                App.render.draw();
            },
            
            deleteLayer(index) {
                if (confirm('Delete this layer?')) {
                    App.state.data.layers.splice(index, 1);
                    this.updateLayerList();
                    App.ui.toast("Layer deleted");
                }
            },
            
            mergeLayers() {
                if (App.state.data.layers.length <= 1) {
                    App.ui.toast("Need at least 2 layers to merge");
                    return;
                }
                
                // Merge all layers into one
                App.ui.toast("Layers merged");
            }
        };

        // ============================================
        // CROP MANAGEMENT
        // ============================================
        App.crop = {
            start() {
                App.tools.setMode('crop');
                App.cropStart = null;
                App.cropEnd = null;
            },
            
            cancel() {
                App.tools.setMode('pan');
            },
            
            apply() {
                if (!App.cropStart || !App.cropEnd) {
                    App.ui.toast("Please select a crop area first");
                    return;
                }
                
                const x = Math.min(App.cropStart.x, App.cropEnd.x);
                const y = Math.min(App.cropStart.y, App.cropEnd.y);
                const width = Math.abs(App.cropEnd.x - App.cropStart.x);
                const height = Math.abs(App.cropEnd.y - App.cropStart.y);
                
                if (width < 10 || height < 10) {
                    App.ui.toast("Crop area too small");
                    return;
                }
                
                App.history.saveState();
                
                // Create cropped image
                const tempCanvas = document.createElement('canvas');
                tempCanvas.width = width;
                tempCanvas.height = height;
                const tempCtx = tempCanvas.getContext('2d');
                
                // Draw cropped portion
                tempCtx.drawImage(
                    App.sourceImage,
                    x, y, width, height,
                    0, 0, width, height
                );
                
                // Replace source image
                const newImage = new Image();
                newImage.onload = () => {
                    App.sourceImage = newImage;
                    App.state.set('rotation', 0);
                    App.state.set('gridOffsetX', 0);
                    App.state.set('gridOffsetY', 0);
                    App.tools.setMode('pan');
                    App.render.draw();
                    App.ui.updateImageInfo();
                    App.ui.toast(`Image cropped to ${width} Ã— ${height}`);
                };
                newImage.src = tempCanvas.toDataURL();
            }
        };

        // ============================================
        // EDIT & FILTERS
        // ============================================
        App.edit = {
            rotate(degrees) {
                App.history.saveState();
                const current = App.state.data.rotation;
                App.state.set('rotation', (current + degrees) % 360);
                App.ui.toast(`Rotated ${degrees}Â°`);
            },
            
            flip(axis) {
                App.history.saveState();
                if (axis === 'h') {
                    App.state.toggle('flipH');
                    App.ui.toast("Flipped horizontally");
                } else if (axis === 'v') {
                    App.state.toggle('flipV');
                    App.ui.toast("Flipped vertically");
                }
            },
            
            toggleBW() {
                App.history.saveState();
                App.state.toggle('isBW');
                App.ui.toast(App.state.data.isBW ? "Black & White filter applied" : "Black & White filter removed");
            },
            
            toggleInvert() {
                App.history.saveState();
                App.state.toggle('isInvert');
                App.ui.tovert(App.state.data.isInvert ? "Invert filter applied" : "Invert filter removed");
            },
            
            toggleSepia() {
                App.history.saveState();
                App.state.toggle('isSepia');
                App.ui.toast(App.state.data.isSepia ? "Sepia filter applied" : "Sepia filter removed");
            },
            
            resetFilters() {
                App.history.saveState();
                App.state.set('filterBright', 100);
                App.state.set('filterContrast', 100);
                App.state.set('filterSat', 100);
                App.state.set('filterHue', 0);
                App.state.set('filterBlur', 0);
                App.state.set('filterTemp', 0);
                App.state.set('filterTint', 0);
                App.state.set('filterExposure', 0);
                App.state.set('filterGamma', 1);
                App.state.set('filterHighlights', 0);
                App.state.set('filterShadows', 0);
                App.state.set('filterSharpen', 0);
                App.state.set('filterNoise', 0);
                App.state.set('filterVignette', 0);
                App.state.set('isBW', false);
                App.state.set('isInvert', false);
                App.state.set('isSepia', false);
                App.ui.toast("All filters reset");
            },
            
            applyVintage() {
                App.history.saveState();
                App.state.set('filterSat', 80);
                App.state.set('filterContrast', 110);
                App.state.set('filterTemp', 20);
                App.state.set('filterVignette', 30);
                App.state.set('isSepia', true);
                App.ui.toast("Vintage filter applied");
            },
            
            applyDramatic() {
                App.history.saveState();
                App.state.set('filterContrast', 130);
                App.state.set('filterSat', 120);
                App.state.set('filterExposure', 0.2);
                App.state.set('filterVignette', 50);
                App.ui.toast("Dramatic filter applied");
            },
            
            applyCool() {
                App.history.saveState();
                App.state.set('filterTemp', -30);
                App.state.set('filterTint', 10);
                App.ui.toast("Cool filter applied");
            },
            
            applyWarm() {
                App.history.saveState();
                App.state.set('filterTemp', 30);
                App.state.set('filterTint', -10);
                App.ui.toast("Warm filter applied");
            },
            
            autoLevels() {
                App.history.saveState();
                // Simple auto levels
                App.state.set('filterContrast', 110);
                App.state.set('filterBright', 105);
                App.ui.toast("Auto levels applied");
            },
            
            autoContrast() {
                App.history.saveState();
                App.state.set('filterContrast', 120);
                App.ui.toast("Auto contrast applied");
            },
            
            autoColor() {
                App.history.saveState();
                App.state.set('filterSat', 110);
                App.state.set('filterTemp', 5);
                App.ui.toast("Auto color applied");
            }
        };

        // ============================================
        // EXPORT & SHARE
        // ============================================
        App.export = {
            download(format = 'png') {
                if (!App.sourceImage) {
                    App.ui.toast("Please load an image first");
                    return;
                }
                
                const scale = parseFloat(document.getElementById('exportScale').value) || 1;
                const quality = parseInt(document.getElementById('exportQuality').value) / 100 || 0.9;
                const includeGrid = document.getElementById('exportWithGrid').checked;
                const includeAnnotations = document.getElementById('exportWithAnnotations').checked;
                
                // Create export canvas
                const exportCanvas = document.createElement('canvas');
                const exportCtx = exportCanvas.getContext('2d');
                
                // Calculate export dimensions
                exportCanvas.width = App.canvas.width * scale;
                exportCanvas.height = App.canvas.height * scale;
                
                // Scale context
                exportCtx.scale(scale, scale);
                
                // Draw background
                exportCtx.fillStyle = includeGrid ? 'transparent' : '#000000';
                exportCtx.fillRect(0, 0, exportCanvas.width, exportCanvas.height);
                
                // Draw image with current filters
                exportCtx.save();
                
                // Apply filters
                const s = App.state.data;
                let filterStr = '';
                if (s.filterBright !== 100) filterStr += `brightness(${s.filterBright}%) `;
                if (s.filterContrast !== 100) filterStr += `contrast(${s.filterContrast}%) `;
                if (s.filterSat !== 100) filterStr += `saturate(${s.filterSat}%) `;
                if (s.filterHue !== 0) filterStr += `hue-rotate(${s.filterHue}deg) `;
                if (s.filterBlur > 0) filterStr += `blur(${s.filterBlur}px) `;
                if (s.isBW) filterStr += 'grayscale(100%) ';
                if (s.isInvert) filterStr += 'invert(100%) ';
                if (s.isSepia) filterStr += 'sepia(100%) ';
                
                if (filterStr) {
                    exportCtx.filter = filterStr.trim();
                }
                
                // Draw image
                const w = App.canvas.width;
                const h = App.canvas.height;
                exportCtx.translate(w / 2, h / 2);
                exportCtx.rotate(s.rotation * Math.PI / 180);
                exportCtx.scale(s.flipH ? -1 : 1, s.flipV ? -1 : 1);
                exportCtx.drawImage(App.sourceImage, -App.sourceImage.width / 2, -App.sourceImage.height / 2);
                
                exportCtx.restore();
                
                // Draw grid if enabled
                if (includeGrid && s.gridVisible) {
                    // Save current state and draw grid
                    exportCtx.save();
                    exportCtx.globalCompositeOperation = s.gridBlend;
                    App.render.drawGrid(w, h);
                    exportCtx.restore();
                }
                
                // Draw annotations if enabled
                if (includeAnnotations) {
                    App.render.drawAnnotations();
                    App.render.drawTextItems();
                    App.render.drawShapes();
                }
                
                // Create download link
                const link = document.createElement('a');
                let mimeType, extension;
                
                switch (format) {
                    case 'jpg':
                    case 'jpeg':
                        mimeType = 'image/jpeg';
                        extension = 'jpg';
                        break;
                    case 'webp':
                        mimeType = 'image/webp';
                        extension = 'webp';
                        break;
                    default:
                        mimeType = 'image/png';
                        extension = 'png';
                }
                
                link.download = `grid-image-${Date.now()}.${extension}`;
                link.href = exportCanvas.toDataURL(mimeType, quality);
                link.click();
                
                App.ui.toast(`Image exported as ${extension.toUpperCase()}`);
            },
            
            copyToClipboard() {
                if (!App.sourceImage) {
                    App.ui.toast("Please load an image first");
                    return;
                }
                
                App.canvas.toBlob(blob => {
                    const item = new ClipboardItem({ 'image/png': blob });
                    navigator.clipboard.write([item]).then(() => {
                        App.ui.toast("Image copied to clipboard");
                    }).catch(err => {
                        console.error('Failed to copy:', err);
                        App.ui.toast("Failed to copy to clipboard");
                    });
                });
            },
            
            print() {
                window.print();
            },
            
            openInNewTab() {
                if (!App.sourceImage) {
                    App.ui.toast("Please load an image first");
                    return;
                }
                
                const dataUrl = App.canvas.toDataURL('image/png');
                const newWindow = window.open();
                newWindow.document.write(`<img src="${dataUrl}" style="max-width:100%;">`);
            },
            
            preset(type) {
                switch (type) {
                    case 'social':
                        document.getElementById('exportScale').value = '2';
                        document.getElementById('exportQuality').value = '85';
                        App.ui.toast("Social media preset applied");
                        break;
                    case 'print':
                        document.getElementById('exportScale').value = '2';
                        document.getElementById('exportQuality').value = '100';
                        App.ui.toast("Print preset applied");
                        break;
                    case 'web':
                        document.getElementById('exportScale').value = '1';
                        document.getElementById('exportQuality').value = '75';
                        App.ui.toast("Web optimized preset applied");
                        break;
                    case 'full':
                        document.getElementById('exportScale').value = '1';
                        document.getElementById('exportQuality').value = '100';
                        App.ui.toast("Full quality preset applied");
                        break;
                }
            }
        };

        App.share = {
            twitter() {
                const text = encodeURIComponent("Check out this image I created with Grid Generator!");
                const url = encodeURIComponent(window.location.href);
                window.open(`https://twitter.com/intent/tweet?text=${text}&url=${url}`, '_blank');
            },
            
            facebook() {
                const url = encodeURIComponent(window.location.href);
                window.open(`https://www.facebook.com/sharer/sharer.php?u=${url}`, '_blank');
            },
            
            downloadJSON() {
                const project = {
                    version: '3.0.0',
                    state: App.state.data,
                    imageSrc: App.sourceImage ? App.sourceImage.src : null,
                    timestamp: new Date().toISOString()
                };
                
                const json = JSON.stringify(project);
                const blob = new Blob([json], { type: 'application/json' });
                const link = document.createElement('a');
                link.download = `grid-project-${Date.now()}.json`;
                link.href = URL.createObjectURL(blob);
                link.click();
                
                App.ui.toast("Project saved");
            },
            
            loadJSON() {
                const input = document.createElement('input');
                input.type = 'file';
                input.accept = '.json';
                
                input.onchange = (e) => {
                    const file = e.target.files[0];
                    if (!file) return;
                    
                    const reader = new FileReader();
                    reader.onload = (e) => {
                        try {
                            const project = JSON.parse(e.target.result);
                            
                            if (project.version && project.state) {
                                // Load state
                                App.state.data = project.state;
                                
                                // Load image if included
                                if (project.imageSrc) {
                                    const img = new Image();
                                    img.onload = () => {
                                        App.sourceImage = img;
                                        App.render.draw();
                                        App.ui.updateInputs();
                                        App.ui.updateImageInfo();
                                        App.ui.toast("Project loaded successfully");
                                    };
                                    img.src = project.imageSrc;
                                } else {
                                    App.render.draw();
                                    App.ui.updateInputs();
                                    App.ui.toast("Project loaded successfully");
                                }
                            } else {
                                App.ui.toast("Invalid project file");
                            }
                        } catch (err) {
                            console.error(err);
                            App.ui.toast("Error loading project file");
                        }
                    };
                    reader.readAsText(file);
                };
                
                input.click();
            }
        };

        // ============================================
        // BATCH PROCESSING
        // ============================================
        App.batch = {
            processGrid() {
                App.ui.toast("Batch processing started");
                // Implementation for batch processing
            },
            
            exportAll() {
                App.ui.toast("Exporting all images");
                // Implementation for batch export
            }
        };

        // ============================================
        // GUIDES
        // ============================================
        App.guides = {
            clearAll() {
                App.state.set('guideCenter', false);
                App.state.set('guideThirds', false);
                App.state.set('guideDiag', false);
                App.state.set('guideGolden', false);
                App.state.set('guideSpiral', false);
                App.state.set('guideFibonacci', false);
                App.state.set('guidePerspective', false);
                App.ui.toast("All guides cleared");
            }
        };

        // ============================================
        // EVENT HANDLING
        // ============================================
        App.events = {
            init() {
                this.setupMouseEvents();
                this.setupDragDrop();
                this.setupKeyboard();
                this.setupFileInput();
                this.setupPasteEvent();
            },
            
            setupMouseEvents() {
                const vp = App.viewport;
                const canvas = App.canvas;
                
                // Mouse down
                vp.addEventListener('mousedown', (e) => {
                    e.preventDefault();
                    App.isDragging = true;
                    App.lastMouse = { x: e.clientX, y: e.clientY };
                    
                    const point = this.getCanvasPoint(e);
                    const mode = App.state.data.currentMode;
                    
                    switch (mode) {
                        case 'draw':
                            App.history.saveState();
                            App.draw.currentPath = {
                                mode: App.state.data.drawMode,
                                color: App.state.data.drawColor,
                                size: App.state.data.drawSize,
                                opacity: App.state.data.drawOpacity,
                                points: [point]
                            };
                            App.state.data.drawPaths.push(App.draw.currentPath);
                            break;
                            
                        case 'measure':
                            App.measureStart = point;
                            App.measureEnd = point;
                            break;
                            
                        case 'crop':
                            App.cropStart = point;
                            App.cropEnd = point;
                            break;
                            
                        case 'text':
                            App.text.addText(point.x, point.y, "Text");
                            break;
                            
                        case 'pan':
                            if (!App.state.data.locked) {
                                vp.style.cursor = 'grabbing';
                            }
                            break;
                    }
                });
                
                // Mouse move
                window.addEventListener('mousemove', (e) => {
                    if (!App.isDragging) return;
                    
                    const point = this.getCanvasPoint(e);
                    const mode = App.state.data.currentMode;
                    
                    switch (mode) {
                        case 'pan':
                            if (!App.state.data.locked) {
                                const dx = e.clientX - App.lastMouse.x;
                                const dy = e.clientY - App.lastMouse.y;
                                App.state.set('panX', App.state.data.panX + dx);
                                App.state.set('panY', App.state.data.panY + dy);
                                App.lastMouse = { x: e.clientX, y: e.clientY };
                            }
                            break;
                            
                        case 'draw':
                            if (App.draw.currentPath) {
                                App.draw.currentPath.points.push(point);
                                App.render.draw();
                            }
                            break;
                            
                        case 'measure':
                            App.measureEnd = point;
                            App.render.draw();
                            break;
                            
                        case 'crop':
                            App.cropEnd = point;
                            App.render.draw();
                            break;
                    }
                });
                
                // Mouse up
                window.addEventListener('mouseup', () => {
                    if (App.isDragging) {
                        App.isDragging = false;
                        App.viewport.style.cursor = '';
                        App.draw.currentPath = null;
                        
                        // Auto-save after drawing
                        if (App.state.data.currentMode === 'draw') {
                            // History already saved on mousedown
                        }
                    }
                });
                
                // Wheel zoom
                vp.addEventListener('wheel', (e) => {
                    e.preventDefault();
                    if (App.state.data.locked) return;
                    
                    const delta = e.deltaY > 0 ? -0.1 : 0.1;
                    App.view.zoom(delta);
                }, { passive: false });
                
                // Double-click to add text
                canvas.addEventListener('dblclick', (e) => {
                    const point = this.getCanvasPoint(e);
                    App.text.addText(point.x, point.y, "Double-click to edit");
                });
            },
            
            setupDragDrop() {
                const dropZone = document.getElementById('dropZone');
                
                window.addEventListener('dragover', (e) => {
                    e.preventDefault();
                    dropZone.classList.add('active');
                });
                
                window.addEventListener('dragleave', (e) => {
                    if (e.target === dropZone || !dropZone.contains(e.relatedTarget)) {
                        dropZone.classList.remove('active');
                    }
                });
                
                window.addEventListener('drop', (e) => {
                    e.preventDefault();
                    dropZone.classList.remove('active');
                    
                    if (e.dataTransfer.files.length > 0) {
                        this.loadFile(e.dataTransfer.files[0]);
                    }
                });
            },
            
            setupFileInput() {
                const fileInput = document.getElementById('fileInput');
                fileInput.addEventListener('change', (e) => {
                    if (e.target.files[0]) {
                        this.loadFile(e.target.files[0]);
                    }
                });
            },
            
            setupPasteEvent() {
                window.addEventListener('paste', (e) => {
                    const items = e.clipboardData.items;
                    
                    for (let i = 0; i < items.length; i++) {
                        if (items[i].type.indexOf('image') !== -1) {
                            const blob = items[i].getAsFile();
                            this.loadFile(blob);
                            e.preventDefault();
                            break;
                        }
                    }
                });
            },
            
            setupKeyboard() {
                window.addEventListener('keydown', (e) => {
                    // Don't intercept keyboard events in input fields
                    if (['INPUT', 'TEXTAREA', 'SELECT'].includes(document.activeElement.tagName)) {
                        return;
                    }
                    
                    const key = e.key.toLowerCase();
                    const ctrl = e.ctrlKey || e.metaKey;
                    const shift = e.shiftKey;
                    
                    // Handle keyboard shortcuts
                    if (ctrl) {
                        switch (key) {
                            case 'z':
                                e.preventDefault();
                                App.history.undo();
                                return;
                            case 'y':
                                e.preventDefault();
                                App.history.redo();
                                return;
                            case 's':
                                e.preventDefault();
                                App.ui.showModal('export');
                                return;
                            case 'o':
                                e.preventDefault();
                                document.getElementById('fileInput').click();
                                return;
                            case 't':
                                e.preventDefault();
                                App.ui.showModal('theme');
                                return;
                            case '+':
                            case '=':
                                e.preventDefault();
                                App.view.zoom(0.1);
                                return;
                            case '-':
                                e.preventDefault();
                                App.view.zoom(-0.1);
                                return;
                            case '0':
                                e.preventDefault();
                                App.view.reset();
                                return;
                        }
                    }
                    
                    if (ctrl && shift) {
                        switch (key) {
                            case 'c':
                                e.preventDefault();
                                App.export.copyToClipboard();
                                return;
                            case 'delete':
                                e.preventDefault();
                                App.clearAll();
                                return;
                        }
                    }
                    
                    // Single key shortcuts
                    switch (key) {
                        case 'escape':
                            App.tools.setMode('pan');
                            break;
                        case 'h':
                            App.state.toggle('gridVisible');
                            break;
                        case 'f':
                            App.ui.toggleSidebar();
                            break;
                        case 'c':
                            App.crop.start();
                            break;
                        case 'd':
                            App.tools.setMode('draw');
                            break;
                        case 'm':
                            App.tools.setMode('measure');
                            break;
                        case 't':
                            App.tools.setMode('text');
                            break;
                        case 's':
                            App.tools.setMode('shape');
                            break;
                        case 'l':
                            App.view.toggleLock();
                            break;
                        case 'r':
                            App.view.reset();
                            break;
                        case ' ':
                            if (!App.state.data.locked) {
                                App.tools.setMode('pan');
                            }
                            break;
                        case 'arrowup':
                            App.state.set('gridOffsetY', App.state.data.gridOffsetY - (shift ? 10 : 1));
                            break;
                        case 'arrowdown':
                            App.state.set('gridOffsetY', App.state.data.gridOffsetY + (shift ? 10 : 1));
                            break;
                        case 'arrowleft':
                            App.state.set('gridOffsetX', App.state.data.gridOffsetX - (shift ? 10 : 1));
                            break;
                        case 'arrowright':
                            App.state.set('gridOffsetX', App.state.data.gridOffsetX + (shift ? 10 : 1));
                            break;
                    }
                });
            },
            
            getCanvasPoint(e) {
                const rect = App.canvas.getBoundingClientRect();
                const scaleX = App.canvas.width / rect.width;
                const scaleY = App.canvas.height / rect.height;
                
                return {
                    x: (e.clientX - rect.left) * scaleX,
                    y: (e.clientY - rect.top) * scaleY
                };
            },
            
            loadFile(file) {
                if (!file.type.match('image.*')) {
                    App.ui.toast("Please select an image file");
                    return;
                }
                
                // Show loading overlay
                const loading = document.getElementById('loadingOverlay');
                const loadingText = document.getElementById('loadingText');
                loading.classList.add('active');
                loadingText.textContent = `Loading ${file.name}...`;
                
                const reader = new FileReader();
                reader.onload = (e) => {
                    const img = new Image();
                    img.onload = () => {
                        App.sourceImage = img;
                        App.sourceImageName = file.name.replace(/\.[^/.]+$/, "");
                        
                        // Save to history
                        App.history.saveState();
                        
                        // Reset view
                        App.state.set('zoom', 1);
                        App.state.set('panX', 0);
                        App.state.set('panY', 0);
                        App.state.set('rotation', 0);
                        
                        // Render
                        App.render.draw();
                        
                        // Update UI
                        App.ui.updateImageInfo();
                        
                        // Hide loading
                        loading.classList.remove('active');
                        
                        App.ui.toast(`Image loaded: ${img.width} Ã— ${img.height}`);
                    };
                    
                    img.onerror = () => {
                        loading.classList.remove('active');
                        App.ui.toast("Error loading image");
                    };
                    
                    img.src = e.target.result;
                };
                
                reader.onerror = () => {
                    loading.classList.remove('active');
                    App.ui.toast("Error reading file");
                };
                
                reader.readAsDataURL(file);
            }
        };

        // ============================================
        // UI MANAGEMENT
        // ============================================
        App.ui = {
            init() {
                this.setupThemeSelector();
                this.setupExportSliders();
                this.updateImageInfo();
                this.updateModeUI();
            },
            
            setupThemeSelector() {
                // Theme selector already initialized by ThemeManager
            },
            
            setupExportSliders() {
                const qualitySlider = document.getElementById('exportQuality');
                if (qualitySlider) {
                    qualitySlider.addEventListener('input', (e) => {
                        document.getElementById('qualityValue').textContent = e.target.value + '%';
                    });
                }
            },
            
            switchTab(tabId) {
                // Update tab buttons
                document.querySelectorAll('.tab-btn').forEach(btn => {
                    btn.classList.remove('active');
                });
                
                document.querySelectorAll('.tab-content').forEach(content => {
                    content.classList.remove('active');
                });
                
                // Activate selected tab
                event.target.classList.add('active');
                document.getElementById('tab-' + tabId).classList.add('active');
                
                // Scroll to top of sidebar
                const sidebarScroll = document.querySelector('.sidebar-scroll');
                sidebarScroll.scrollTop = 0;
            },
            
            toggleSidebar() {
                const sidebar = document.getElementById('sidebar');
                sidebar.classList.toggle('collapsed');
                
                const btn = event.target;
                btn.innerHTML = sidebar.classList.contains('collapsed') ? 'â›¶' : 'â›¶';
                btn.title = sidebar.classList.contains('collapsed') ? 'Show UI (F)' : 'Focus Mode (F)';
                
                App.ui.toast(sidebar.classList.contains('collapsed') ? 'Focus mode enabled' : 'Focus mode disabled');
            },
            
            showModal(modalId) {
                const modal = document.getElementById(`modal${modalId.charAt(0).toUpperCase() + modalId.slice(1)}`);
                if (modal) {
                    modal.classList.add('open');
                }
            },
            
            closeModal(modalId) {
                const modal = document.getElementById(`modal${modalId.charAt(0).toUpperCase() + modalId.slice(1)}`);
                if (modal) {
                    modal.classList.remove('open');
                }
            },
            
            updateInputs() {
                const s = App.state.data;
                
                // Helper function to update input values
                const update = (id, value) => {
                    const el = document.getElementById(id);
                    if (!el) return;
                    
                    if (el.type === 'checkbox') {
                        el.checked = value;
                    } else if (el.type === 'radio') {
                        // Radio buttons handled separately
                    } else {
                        el.value = value;
                    }
                };
                
                // Update all inputs based on state
                update('gridRows', s.gridRows);
                update('gridCols', s.gridCols);
                update('gridWidth', s.gridWidth);
                update('gridHeight', s.gridHeight);
                update('gridDensity', s.gridDensity);
                update('gridColor', s.gridColor);
                update('gridThick', s.gridThick);
                update('gridOpacity', s.gridOpacity);
                update('gridBlend', s.gridBlend);
                update('gridLineStyle', s.gridLineStyle);
                update('gridOffsetX', s.gridOffsetX);
                update('gridOffsetY', s.gridOffsetY);
                update('gridRotation', s.gridRotation);
                update('showLabels', s.showLabels);
                update('labelSize', s.labelSize);
                update('labelColor', s.labelColor);
                update('showCoordinates', s.showCoordinates);
                
                // Sub-grid
                update('subGridEnabled', s.subGridEnabled);
                update('subGridDivs', s.subGridDivs);
                update('subGridColor', s.subGridColor);
                update('subGridOpacity', s.subGridOpacity);
                update('subGridLineStyle', s.subGridLineStyle);
                update('subGridThick', s.subGridThick);
                update('subGridType', s.subGridType);
                update('subGridNumbers', s.subGridNumbers);
                
                // Patterns
                update('gridPattern', s.gridPattern);
                update('patternScale', s.patternScale);
                update('patternColor', s.patternColor);
                update('patternOpacity', s.patternOpacity);
                
                // Snap
                update('snapToGrid', s.snapToGrid);
                update('snapStrength', s.snapStrength);
                update('snapRadius', s.snapRadius);
                update('showSnapPoints', s.showSnapPoints);
                
                // Guides
                update('guideCenter', s.guideCenter);
                update('guideThirds', s.guideThirds);
                update('guideDiag', s.guideDiag);
                update('guideGolden', s.guideGolden);
                update('guideSpiral', s.guideSpiral);
                update('guideFibonacci', s.guideFibonacci);
                update('guidePerspective', s.guidePerspective);
                update('showGridStats', s.showGridStats);
                
                // Drawing
                update('drawColor', s.drawColor);
                update('drawSize', s.drawSize);
                update('drawOpacity', s.drawOpacity);
                update('drawBrushType', s.drawBrushType);
                update('drawPressure', s.drawPressure);
                update('drawSmooth', s.drawSmooth);
                update('drawFillShapes', s.drawFillShapes);
                update('showMeasurements', s.showMeasurements);
                
                // Filters
                update('filterBright', s.filterBright);
                update('filterContrast', s.filterContrast);
                update('filterSat', s.filterSat);
                update('filterHue', s.filterHue);
                update('filterBlur', s.filterBlur);
                update('filterTemp', s.filterTemp);
                update('filterTint', s.filterTint);
                update('filterExposure', s.filterExposure);
                update('filterGamma', s.filterGamma);
                update('filterHighlights', s.filterHighlights);
                update('filterShadows', s.filterShadows);
                update('filterSharpen', s.filterSharpen);
                update('filterNoise', s.filterNoise);
                update('filterVignette', s.filterVignette);
                
                // Show/hide relevant sections
                const showElement = (id, condition) => {
                    const el = document.getElementById(id);
                    if (el) el.classList.toggle('hidden', !condition);
                };
                
                showElement('inputGroupCount', s.gridMode === 'count');
                showElement('inputGroupSize', s.gridMode === 'size');
                showElement('inputGroupAuto', s.gridMode === 'auto');
                showElement('subGridControls', s.subGridEnabled);
                
                // Update active buttons
                const setActive = (id, condition) => {
                    const el = document.getElementById(id);
                    if (el) el.classList.toggle('active', condition);
                };
                
                setActive('modeCount', s.gridMode === 'count');
                setActive('modeSize', s.gridMode === 'size');
                setActive('modeAuto', s.gridMode === 'auto');
                setActive('tgCenter', s.guideCenter);
                setActive('tgThirds', s.guideThirds);
                setActive('tgDiag', s.guideDiag);
                setActive('tgGolden', s.guideGolden);
                setActive('tgSpiral', s.guideSpiral);
                setActive('tgFibonacci', s.guideFibonacci);
                setActive('tgPerspective', s.guidePerspective);
            },
            
            updateModeUI() {
                const mode = App.state.data.currentMode;
                const vp = App.viewport;
                
                // Reset all mode classes
                vp.className = 'viewport';
                vp.classList.add(`mode-${mode}`);
                
                // Update tool buttons
                const tools = ['pan', 'draw', 'measure', 'text', 'shape'];
                tools.forEach(tool => {
                    const btn = document.getElementById(`tool${tool.charAt(0).toUpperCase() + tool.slice(1)}`);
                    if (btn) btn.classList.toggle('active', mode === tool);
                });
                
                // Update draw mode buttons
                const drawModes = ['pen', 'eraser', 'line', 'arrow', 'rectangle', 'circle', 'text'];
                drawModes.forEach(drawMode => {
                    const btn = document.getElementById(`btnDraw${drawMode.charAt(0).toUpperCase() + drawMode.slice(1)}`);
                    if (btn) btn.classList.toggle('active', App.state.data.drawMode === drawMode && mode === 'draw');
                });
            },
            
            updateImageInfo() {
                const container = document.getElementById('imageInfo');
                
                if (!App.sourceImage) {
                    container.innerHTML = '<div class="row"><span class="text-sm opacity-75">No image loaded</span></div>';
                    return;
                }
                
                const img = App.sourceImage;
                const sizeInMB = (img.width * img.height * 4) / (1024 * 1024);
                
                container.innerHTML = `
                    <div class="row justify-between">
                        <span class="text-sm opacity-75">Dimensions:</span>
                        <span class="text-sm font-mono">${img.width} Ã— ${img.height}</span>
                    </div>
                    <div class="row justify-between">
                        <span class="text-sm opacity-75">Aspect Ratio:</span>
                        <span class="text-sm font-mono">${this.calculateAspectRatio(img.width, img.height)}</span>
                    </div>
                    <div class="row justify-between">
                        <span class="text-sm opacity-75">Estimated Size:</span>
                        <span class="text-sm font-mono">${sizeInMB.toFixed(2)} MB</span>
                    </div>
                    <div class="row justify-between">
                        <span class="text-sm opacity-75">Color Space:</span>
                        <span class="text-sm font-mono">RGB</span>
                    </div>
                `;
            },
            
            calculateAspectRatio(width, height) {
                const gcd = (a, b) => {
                    return b ? gcd(b, a % b) : a;
                };
                
                const divisor = gcd(width, height);
                return `${width / divisor}:${height / divisor}`;
            },
            
            toast(message, duration = 2000) {
                const toast = document.getElementById('toast');
                toast.textContent = message;
                toast.classList.add('visible');
                
                setTimeout(() => {
                    toast.classList.remove('visible');
                }, duration);
            },
            
            applyCustomTheme() {
                ThemeManager.applyCustomTheme();
                this.toast("Custom theme applied");
            },
            
            resetCustomTheme() {
                ThemeManager.resetCustomTheme();
                this.toast("Custom theme reset");
            }
        };

        // ============================================
        // INITIALIZATION
        // ============================================
        document.addEventListener('DOMContentLoaded', () => {
            App.init();
        });

        // Global functions for HTML event handlers
        window.openModal = (modalId) => App.ui.showModal(modalId);
        window.closeModal = (modalId) => App.ui.closeModal(modalId);

    </script>
</body>
</html>